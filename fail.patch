diff --git a/Makefile b/Makefile
index 7650065..6aa116c 100644
--- a/Makefile
+++ b/Makefile
@@ -57,7 +57,7 @@ clean:
 	$(MAKE) -C libc clean
 	$(MAKE) -C mkfs clean
 	rm -f .gdbinit $(KERNEL_IMG) $(FS_IMG)
-	rm -rf $(FS_PATH)/bin/* $(FS_PATH)/init $(FS_PATH)/sh
+	rm -rf $(FS_PATH)/bin/* $(FS_PATH)/init
 # Форматирует весь код
 format:
 	@echo "Astyle code formatter"
@@ -96,7 +96,6 @@ fs_bin: apps
 	cp -f -t $(FS_PATH)/bin $(wildcard apps/_*)
 	cd $(FS_PATH)/bin && rename 's/_//' *
 	mv -f $(FS_PATH)/bin/init $(FS_PATH)
-	mv -f $(FS_PATH)/bin/sh $(FS_PATH)
 
 # Для файловой системы в памяти
 # Не работает в данынй момент
diff --git a/apps/env.c b/apps/env.c
new file mode 100644
index 0000000..af7f4d9
--- /dev/null
+++ b/apps/env.c
@@ -0,0 +1,14 @@
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <user.h>
+
+int
+main(int argc, char *argv[], char *envp[]) {
+	int i;
+
+	for (i = 0; envp[i]; i++) {
+		printf(1, "%s\n", envp[i]);
+	}
+
+	return 0;
+}
diff --git a/apps/fstest.c b/apps/fstest.c
new file mode 100644
index 0000000..004cae4
--- /dev/null
+++ b/apps/fstest.c
@@ -0,0 +1,26 @@
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/fs.h>
+#include <sys/file.h>
+#include <user.h>
+
+int
+main(int argc, char *argv[]) {
+	char buf[4];
+	int fd = open("/t", 0);
+	int n;
+	int pos=5;
+
+	if(seek(fd, pos, 2) < 0)
+		goto bad;
+
+	while ((n = read(fd, buf, sizeof(buf))) > 0) {
+		write(1, buf, n);
+
+		printf(1, " pos %d\n", tell(fd));
+	}
+bad:
+	printf(1, "exit\n");
+
+	exit();
+}
diff --git a/apps/init.c b/apps/init.c
index 49f446e..7dabbf1 100644
--- a/apps/init.c
+++ b/apps/init.c
@@ -5,12 +5,35 @@
 #include <user.h>
 #include <sys/fcntl.h>
 
-char *argv[] = { "sh", 0 };
-char *envp[] = {"PATH=/bin:", "USER=lain", 0};
+char *
+fgets(char *buf, int max, int fd) {
+	int i, cc;
+	char c;
+
+	for (i = 0; i + 1 < max;) {
+		cc = read(fd, &c, 1);
+
+		if (cc < 1) {
+			break;
+		}
+
+		buf[i++] = c;
+
+		if (c == '\n' || c == '\r') {
+			break;
+		}
+	}
+
+	buf[i] = '\0';
+	return buf;
+}
+
 
 int
 main(void) {
 	int pid, wpid;
+	char buf[512];
+	int fd;
 
 	if (open("/dev/console", O_RDWR) < 0) {
 		mknod("/dev/console", 1, 1);
@@ -20,6 +43,20 @@ main(void) {
 	dup(0);  // stdout
 	dup(0);  // stderr
 
+	// Инициализация переменных окружения
+	if((fd = open("/etc/environment", O_RDONLY)) != 0) {
+		memset(&buf, 0, 512);
+		while(fgets(&buf, 512, fd) && buf[0]) {
+			// Удаляем \n
+			buf[strlen(&buf)-1] = 0;
+			putenv(&buf);
+			memset(&buf, 0, 512);
+		}
+	} else {
+		putenv("PATH=.:/bin");
+		putenv("SHELL=/bin/sh");
+	}
+
 	for (;;) {
 		printf(1, "init: starting sh\n");
 		pid = fork();
@@ -30,7 +67,8 @@ main(void) {
 		}
 
 		if (pid == 0) {
-			execve("sh", argv, envp);
+			char *argv[] = { getenv("SHELL"), 0 };
+			exec(argv[0], argv);
 			printf(1, "init: exec sh failed\n");
 			exit();
 		}
diff --git a/apps/lib/ulib.c b/apps/lib/ulib.c
index 3cbf5ed..46e50cc 100644
--- a/apps/lib/ulib.c
+++ b/apps/lib/ulib.c
@@ -2,8 +2,44 @@
 #include <sys/stat.h>
 #include <sys/fcntl.h>
 #include <user.h>
-#include <sys/x86.h>
 
+#define min(a, b) ((a < b)? a: b)
+
+int exec(const char *name, char **argv) {
+	int fd;
+	char buf[512];
+
+	const char *PATH = getenv("PATH");
+	int PATH_end = PATH+strlen(PATH);
+
+	char *start = PATH;
+	char *end = 0;
+
+	int is = 1;
+	while(is) {
+		end = strchr(start, ':');
+
+		if(end == 0) {
+			is = 0;
+			end = PATH_end;
+		}
+
+		memset(&buf, 0, 512);
+		strncpy(buf, start, min(512, end - start));
+
+		buf[strlen(buf)] = '/';
+		strcpy(buf+strlen(buf), name);
+
+		if ((fd = open(buf, O_RDONLY)) > 0) {
+			return execve(buf, argv, environ);
+		}
+		close(fd);
+
+		start = end+1;
+	}
+
+	return -1;
+}
 
 char *
 gets(char *buf, int max) {
@@ -151,7 +187,6 @@ int unsetenv(const char *name) {
 // FIXME: fail set. Why?
 #define alloca(size)   __builtin_alloca (size)
 int putenv(char *string) {
-	return -1;// ну чтоб не портил ничего
 	char *name_end = strchr(string, '=');
 
 	if (name_end) {
diff --git a/apps/lib/usys.S b/apps/lib/usys.S
index aaee5ec..0a04cff 100644
--- a/apps/lib/usys.S
+++ b/apps/lib/usys.S
@@ -1,5 +1,5 @@
 #include <sys/syscall.h>
-#include <sys/traps.h>
+#include <kernel/traps.h>
 
 #define SYSCALL(name) \
   .globl name; \
@@ -29,3 +29,6 @@ SYSCALL(getpid)
 SYSCALL(sbrk)
 SYSCALL(sleep)
 SYSCALL(uptime)
+
+SYSCALL(tell)
+SYSCALL(seek)
diff --git a/apps/ls.c b/apps/ls.c
index 3a75a9b..ac4f412 100644
--- a/apps/ls.c
+++ b/apps/ls.c
@@ -1,7 +1,7 @@
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <user.h>
-#include <sys/fs.h>
+#include <kernel/fs.h>
 
 char *
 fmtname(char *path) {
diff --git a/apps/sh.c b/apps/sh.c
index 38ce52b..0406626 100644
--- a/apps/sh.c
+++ b/apps/sh.c
@@ -78,21 +78,8 @@ runcmd(struct cmd *cmd) {
 			exit();
 		}
 
-		// Тут магия с PATH
-		char path[512 + 5];
-		strncpy(path, ecmd->argv[0], 512);
-
-		int fd;
-
-		if (fd = open(path, O_RDONLY) < 0) {
-			strncpy(path, "/bin/", 512);
-			strncpy(path + 5, ecmd->argv[0], 512);
-		} else {
-			close(fd);
-		}
-
-		exec(path, ecmd->argv);
-		printf(2, "exec %s failed\n", path);
+		exec(ecmd->argv[0], ecmd->argv);
+		printf(2, "exec %s failed\n", ecmd->argv[0]);
 
 		break;
 
diff --git a/apps/stressfs.c b/apps/stressfs.c
index 25d1204..262c194 100644
--- a/apps/stressfs.c
+++ b/apps/stressfs.c
@@ -10,7 +10,7 @@
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <user.h>
-#include <sys/fs.h>
+#include <kernel/fs.h>
 #include <sys/fcntl.h>
 
 int
diff --git a/apps/testenv.c b/apps/testenv.c
new file mode 100644
index 0000000..cbd946f
--- /dev/null
+++ b/apps/testenv.c
@@ -0,0 +1,72 @@
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <user.h>
+
+#define alloca(size) __builtin_alloca (size)
+
+#define _STEP(function, message...) \
+({ \
+    printf(1, "" #function " " message "\n", function); \
+})
+
+int _all() {
+	int i;
+
+	printf(1, "All envp\n");
+
+	for (i = 0; environ[i]; i++) {
+		printf(1, "    %s\n", environ[i]);
+	}
+}
+
+int
+main(int argc, char *argv[]) {
+
+	_all();
+
+	printf(1, "\n");
+
+	printf(1, "getenv PATH: '%s'\n", getenv("PATH"));
+
+	_STEP(setenv("yyy", "666", 0), "%d");
+	_STEP(getenv("yyy"), "%s");
+
+	_STEP(setenv("xxx", "666", 0), "%d");
+	_STEP(getenv("xxx"), "%s");
+
+	_all();
+
+	_STEP(setenv("xxx", "777", 0), "%d");
+	_STEP(getenv("xxx"), "%s");
+
+	_STEP(setenv("xxx", "888", 1), "%d");
+	_STEP(getenv("xxx"), "%s");
+
+	_STEP(setenv("zzz", "666", 0), "%d");
+	_STEP(getenv("zzz"), "%s");
+
+	_all();
+	_STEP(unsetenv("xxx"), "%d");
+	_STEP(getenv("xxx"), "%s");
+
+	_all();
+
+	_STEP(setenv("xxx", "999", 1), "%d");
+	_STEP(getenv("xxx"), "%s");
+
+	_all();
+
+
+
+	printf(1, "puttenv qwerty: '%d'\n", putenv("qwerty=dwarf"));
+	printf(1, "getenv qwerty: '%s'\n", getenv("qwerty"));
+
+	_all();
+
+	printf(1, "***NEW envp\n");
+	exec("env", 0);
+
+
+
+	return 0;
+}
diff --git a/apps/txt.c b/apps/txt.c
new file mode 100644
index 0000000..ddf7936
--- /dev/null
+++ b/apps/txt.c
@@ -0,0 +1,44 @@
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <user.h>
+
+#include <stdbool.h>
+
+void move_to(int x, int y) {
+	printf(2, "\e[%d;%dH", x, y);
+	// debug
+	printf(2, "X%d;%d", x, y);
+}
+void reset_screen() {
+	printf(2, "\e[2J");
+}
+
+int
+main(int argc, char *argv[]) {
+	int i;
+
+	reset_screen();
+
+	if (false) {
+		printf(1, "args: ");
+
+		for (i = 0; i < argc; i++) {
+			printf(1, "%s%s", argv[i], i + 1 < argc ? " " : "\n");
+		}
+	}
+
+	move_to(80 / 2, 25 / 2);
+	move_to(0, 7);
+	move_to(0, 2);
+	move_to(79, 7);
+	move_to(79, 23);
+	move_to(79, 24);
+
+	char c;
+
+	for (;;) {
+		printf(1, "%d", read(0, &c, 1));
+	}
+
+	exit();
+}
diff --git a/apps/usertests.c b/apps/usertests.c
index 7948930..a93e9b8 100644
--- a/apps/usertests.c
+++ b/apps/usertests.c
@@ -2,11 +2,11 @@
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <user.h>
-#include <sys/fs.h>
+#include <kernel/fs.h>
 #include <sys/fcntl.h>
 #include <sys/syscall.h>
-#include <sys/traps.h>
-#include <sys/memlayout.h>
+#include <kernel/traps.h>
+#include <kernel/memlayout.h>
 
 char buf[8192];
 char name[3];
diff --git a/fs/etc/environment b/fs/etc/environment
new file mode 100644
index 0000000..be24777
--- /dev/null
+++ b/fs/etc/environment
@@ -0,0 +1,4 @@
+PATH=.:/bin
+USER=lain
+HOME=/lain
+SHELL=/bin/sh
diff --git a/fs/lain/.gitkeep b/fs/lain/.gitkeep
new file mode 100644
index 0000000..e69de29
diff --git a/include/kernel/asm.h b/include/kernel/asm.h
new file mode 100644
index 0000000..68210d7
--- /dev/null
+++ b/include/kernel/asm.h
@@ -0,0 +1,21 @@
+//
+// assembler macros to create x86 segments
+//
+
+#define SEG_NULLASM                                             \
+        .word 0, 0;                                             \
+        .byte 0, 0, 0, 0
+
+// The 0xC0 means the limit is in 4096-byte units
+// and (for executable segments) 32-bit mode.
+#define SEG_ASM(type,base,lim)                                  \
+        .word (((lim) >> 12) & 0xffff), ((base) & 0xffff);      \
+        .byte (((base) >> 16) & 0xff), (0x90 | (type)),         \
+                (0xC0 | (((lim) >> 28) & 0xf)), (((base) >> 24) & 0xff)
+
+#define STA_X     0x8       // Executable segment
+#define STA_E     0x4       // Expand down (non-executable segments)
+#define STA_C     0x4       // Conforming code segment (executable only)
+#define STA_W     0x2       // Writeable (non-executable segments)
+#define STA_R     0x2       // Readable (executable segments)
+#define STA_A     0x1       // Accessed
diff --git a/include/kernel/buf.h b/include/kernel/buf.h
new file mode 100644
index 0000000..e7357f0
--- /dev/null
+++ b/include/kernel/buf.h
@@ -0,0 +1,13 @@
+struct buf {
+	int flags;
+	uint dev;
+	uint sector;
+	struct buf *prev; // LRU cache list
+	struct buf *next;
+	struct buf *qnext; // disk queue
+	uchar data[512];
+};
+#define B_BUSY  0x1  // buffer is locked by some process
+#define B_VALID 0x2  // buffer has been read from disk
+#define B_DIRTY 0x4  // buffer needs to be written to disk
+
diff --git a/include/kernel/defs.h b/include/kernel/defs.h
new file mode 100644
index 0000000..0b5223b
--- /dev/null
+++ b/include/kernel/defs.h
@@ -0,0 +1,181 @@
+struct buf;
+struct context;
+struct file;
+struct inode;
+struct pipe;
+struct proc;
+struct spinlock;
+struct stat;
+struct superblock;
+
+// bio.c
+void            binit(void);
+struct buf     *bread(uint, uint);
+void            brelse(struct buf *);
+void            bwrite(struct buf *);
+
+// console.c
+void            consoleinit(void);
+void            cprintf(const char *, ...);
+void            consoleintr(int( *)(void));
+void            panic(const char *) __attribute__((noreturn));
+
+// exec.c
+int             exec(char *, char **);
+
+// file.c
+struct file    *filealloc(void);
+void            fileclose(struct file *);
+struct file    *filedup(struct file *);
+void            fileinit(void);
+int             fileread(struct file *, char *, int n);
+int             filestat(struct file *, struct stat *);
+int             filewrite(struct file *, char *, int n);
+
+// fs.c
+void            readsb(int dev, struct superblock *sb);
+int             dirlink(struct inode *, char *, uint);
+struct inode   *dirlookup(struct inode *, char *, uint *);
+struct inode   *ialloc(uint, short);
+struct inode   *idup(struct inode *);
+void            iinit(void);
+void            ilock(struct inode *);
+void            iput(struct inode *);
+void            iunlock(struct inode *);
+void            iunlockput(struct inode *);
+void            iupdate(struct inode *);
+int             namecmp(const char *, const char *);
+struct inode   *namei(char *);
+struct inode   *nameiparent(char *, char *);
+int             readi(struct inode *, char *, uint, uint);
+void            stati(struct inode *, struct stat *);
+int             writei(struct inode *, char *, uint, uint);
+
+// ide.c
+void            ideinit(void);
+void            ideintr(void);
+void            iderw(struct buf *);
+
+// ioapic.c
+void            ioapicenable(int irq, int cpu);
+extern uchar    ioapicid;
+void            ioapicinit(void);
+
+// kalloc.c
+char           *kalloc(void);
+void            kfree(char *);
+void            kinit1(void *, void *);
+void            kinit2(void *, void *);
+
+// kbd.c
+void            kbdintr(void);
+
+// lapic.c
+int             cpunum(void);
+extern volatile uint    *lapic;
+void            lapiceoi(void);
+void            lapicinit(void);
+void            lapicstartap(uchar, uint);
+void            microdelay(int);
+
+// log.c
+void            initlog(void);
+void            log_write(struct buf *);
+void            begin_trans();
+void            commit_trans();
+
+// mp.c
+extern int      ismp;
+int             mpbcpu(void);
+void            mpinit(void);
+void            mpstartthem(void);
+
+// picirq.c
+void            picenable(int);
+void            picinit(void);
+
+// pipe.c
+int             pipealloc(struct file **, struct file **);
+void            pipeclose(struct pipe *, int);
+int             piperead(struct pipe *, char *, int);
+int             pipewrite(struct pipe *, char *, int);
+
+//PAGEBREAK: 16
+// proc.c
+struct proc    *copyproc(struct proc *);
+void            exit(void);
+int             fork(void);
+int             growproc(int);
+int             kill(int);
+void            pinit(void);
+void            procdump(void);
+void            scheduler(void) __attribute__((noreturn));
+void            sched(void);
+void            sleep(void *, struct spinlock *);
+void            userinit(void);
+int             wait(void);
+void            wakeup(void *);
+void            yield(void);
+
+// swtch.S
+void            swtch(struct context **, struct context *);
+
+// spinlock.c
+void            acquire(struct spinlock *);
+void            getcallerpcs(void *, uint *);
+int             holding(struct spinlock *);
+void            initlock(struct spinlock *, const char *);
+void            release(struct spinlock *);
+void            pushcli(void);
+void            popcli(void);
+
+// string.c
+int             memcmp(const void *, const void *, uint);
+void           *memmove(void *, const void *, uint);
+void           *memset(void *, int, uint);
+char           *safestrcpy(char *, const char *, int);
+int             strlen(const char *);
+int             strncmp(const char *, const char *, uint);
+char           *strncpy(char *, const char *, int);
+
+// syscall.c
+int             argint(int, int *);
+int             argptr(int, char **, int);
+int             argstr(int, char **);
+int             fetchint(uint, int *);
+int             fetchstr(uint, char **);
+void            syscall(void);
+
+// timer.c
+void            timerinit(void);
+
+// trap.c
+void            idtinit(void);
+extern uint     ticks;
+void            tvinit(void);
+extern struct spinlock tickslock;
+
+// uart.c
+void            uartinit(void);
+void            uartintr(void);
+void            uartputc(int);
+
+// vm.c
+void            seginit(void);
+void            kvmalloc(void);
+void            vmenable(void);
+pde_t          *setupkvm(void);
+char           *uva2ka(pde_t *, char *);
+int             allocuvm(pde_t *, uint, uint);
+int             deallocuvm(pde_t *, uint, uint);
+void            freevm(pde_t *);
+void            inituvm(pde_t *, char *, uint);
+int             loaduvm(pde_t *, char *, struct inode *, uint, uint);
+pde_t          *copyuvm(pde_t *, uint);
+void            switchuvm(struct proc *);
+void            switchkvm(void);
+int             copyout(pde_t *, uint, void *, uint);
+void            clearpteu(pde_t *pgdir, char *uva);
+
+// number of elements in fixed-size array
+#define NELEM(x) (sizeof(x)/sizeof((x)[0]))
diff --git a/include/kernel/elf.h b/include/kernel/elf.h
new file mode 100644
index 0000000..acf24b4
--- /dev/null
+++ b/include/kernel/elf.h
@@ -0,0 +1,42 @@
+// Format of an ELF executable file
+
+#define ELF_MAGIC 0x464C457FU  // "\x7FELF" in little endian
+
+// File header
+struct elfhdr {
+	uint magic;  // must equal ELF_MAGIC
+	uchar elf[12];
+	ushort type;
+	ushort machine;
+	uint version;
+	uint entry;
+	uint phoff;
+	uint shoff;
+	uint flags;
+	ushort ehsize;
+	ushort phentsize;
+	ushort phnum;
+	ushort shentsize;
+	ushort shnum;
+	ushort shstrndx;
+};
+
+// Program section header
+struct proghdr {
+	uint type;
+	uint off;
+	uint vaddr;
+	uint paddr;
+	uint filesz;
+	uint memsz;
+	uint flags;
+	uint align;
+};
+
+// Values for Proghdr type
+#define ELF_PROG_LOAD           1
+
+// Flag bits for Proghdr flags
+#define ELF_PROG_FLAG_EXEC      1
+#define ELF_PROG_FLAG_WRITE     2
+#define ELF_PROG_FLAG_READ      4
diff --git a/include/kernel/fcntl.h b/include/kernel/fcntl.h
new file mode 100644
index 0000000..d565483
--- /dev/null
+++ b/include/kernel/fcntl.h
@@ -0,0 +1,4 @@
+#define O_RDONLY  0x000
+#define O_WRONLY  0x001
+#define O_RDWR    0x002
+#define O_CREATE  0x200
diff --git a/include/kernel/file.h b/include/kernel/file.h
new file mode 100644
index 0000000..299d68f
--- /dev/null
+++ b/include/kernel/file.h
@@ -0,0 +1,38 @@
+struct file {
+	enum { FD_NONE, FD_PIPE, FD_INODE } type;
+	int ref; // reference count
+	char readable;
+	char writable;
+	struct pipe *pipe;
+	struct inode *ip;
+	uint off;
+};
+
+
+// in-memory copy of an inode
+struct inode {
+	uint dev;           // Device number
+	uint inum;          // Inode number
+	int ref;            // Reference count
+	int flags;          // I_BUSY, I_VALID
+
+	short type;         // copy of disk inode
+	short major;
+	short minor;
+	short nlink;
+	uint size;
+	uint addrs[NDIRECT + 1];
+};
+#define I_BUSY 0x1
+#define I_VALID 0x2
+
+// table mapping major device number to
+// device functions
+struct devsw {
+	int (*read)(struct inode *, char *, int);
+	int (*write)(struct inode *, char *, int);
+};
+
+extern struct devsw devsw[];
+
+#define CONSOLE 1
diff --git a/include/kernel/fs.h b/include/kernel/fs.h
new file mode 100644
index 0000000..57c621b
--- /dev/null
+++ b/include/kernel/fs.h
@@ -0,0 +1,55 @@
+// On-disk file system format.
+// Both the kernel and user programs use this header file.
+
+// Block 0 is unused.
+// Block 1 is super block.
+// Blocks 2 through sb.ninodes/IPB hold inodes.
+// Then free bitmap blocks holding sb.size bits.
+// Then sb.nblocks data blocks.
+// Then sb.nlog log blocks.
+
+#define ROOTINO 1  // root i-number
+#define BSIZE 512  // block size
+
+// File system super block
+struct superblock {
+	uint size;         // Size of file system image (blocks)
+	uint nblocks;      // Number of data blocks
+	uint ninodes;      // Number of inodes.
+	uint nlog;         // Number of log blocks
+};
+
+#define NDIRECT 12
+#define NINDIRECT (BSIZE / sizeof(uint))
+#define MAXFILE (NDIRECT + NINDIRECT)
+
+// On-disk inode structure
+struct dinode {
+	short type;           // File type
+	short major;          // Major device number (T_DEV only)
+	short minor;          // Minor device number (T_DEV only)
+	short nlink;          // Number of links to inode in file system
+	uint size;            // Size of file (bytes)
+	uint addrs[NDIRECT + 1]; // Data block addresses
+};
+
+// Inodes per block.
+#define IPB           (BSIZE / sizeof(struct dinode))
+
+// Block containing inode i
+#define IBLOCK(i)     ((i) / IPB + 2)
+
+// Bitmap bits per block
+#define BPB           (BSIZE*8)
+
+// Block containing bit for block b
+#define BBLOCK(b, ninodes) (b/BPB + (ninodes)/IPB + 3)
+
+// Directory is a file containing a sequence of dirent structures.
+#define DIRSIZ 14
+
+struct dirent {
+	ushort inum;
+	char name[DIRSIZ];
+};
+
diff --git a/include/kernel/kbd.h b/include/kernel/kbd.h
new file mode 100644
index 0000000..2d05329
--- /dev/null
+++ b/include/kernel/kbd.h
@@ -0,0 +1,107 @@
+// PC keyboard interface constants
+
+#define KBSTATP         0x64    // kbd controller status port(I)
+#define KBS_DIB         0x01    // kbd data in buffer
+#define KBDATAP         0x60    // kbd data port(I)
+
+#define NO              0
+
+#define SHIFT           (1<<0)
+#define CTL             (1<<1)
+#define ALT             (1<<2)
+
+#define CAPSLOCK        (1<<3)
+#define NUMLOCK         (1<<4)
+#define SCROLLLOCK      (1<<5)
+
+#define E0ESC           (1<<6)
+
+// Special keycodes
+#define KEY_HOME        0xE0
+#define KEY_END         0xE1
+#define KEY_UP          0xE2
+#define KEY_DN          0xE3
+#define KEY_LF          0xE4
+#define KEY_RT          0xE5
+#define KEY_PGUP        0xE6
+#define KEY_PGDN        0xE7
+#define KEY_INS         0xE8
+#define KEY_DEL         0xE9
+
+// C('A') == Control-A
+#define C(x) (x - '@')
+
+static uchar shiftcode[256] = {
+	[0x1D] CTL,
+	[0x2A] SHIFT,
+	[0x36] SHIFT,
+	[0x38] ALT,
+	[0x9D] CTL,
+	[0xB8] ALT
+};
+
+static uchar togglecode[256] = {
+	[0x3A] CAPSLOCK,
+	[0x45] NUMLOCK,
+	[0x46] SCROLLLOCK
+};
+
+static uchar normalmap[256] = {
+	NO,   0x1B, '1',  '2',  '3',  '4',  '5',  '6',  // 0x00
+	'7',  '8',  '9',  '0',  '-',  '=',  '\b', '\t',
+	'q',  'w',  'e',  'r',  't',  'y',  'u',  'i',  // 0x10
+	'o',  'p',  '[',  ']',  '\n', NO,   'a',  's',
+	'd',  'f',  'g',  'h',  'j',  'k',  'l',  ';',  // 0x20
+	'\'', '`',  NO,   '\\', 'z',  'x',  'c',  'v',
+	'b',  'n',  'm',  ',',  '.',  '/',  NO,   '*',  // 0x30
+	NO,   ' ',  NO,   NO,   NO,   NO,   NO,   NO,
+	NO,   NO,   NO,   NO,   NO,   NO,   NO,   '7',  // 0x40
+	'8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',
+	'2',  '3',  '0',  '.',  NO,   NO,   NO,   NO,   // 0x50
+	[0x9C] '\n',      // KP_Enter
+	[0xB5] '/',       // KP_Div
+	[0xC8] KEY_UP,    [0xD0] KEY_DN,
+	[0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
+	[0xCB] KEY_LF,    [0xCD] KEY_RT,
+	[0x97] KEY_HOME,  [0xCF] KEY_END,
+	[0xD2] KEY_INS,   [0xD3] KEY_DEL
+};
+
+static uchar shiftmap[256] = {
+	NO,   033,  '!',  '@',  '#',  '$',  '%',  '^',  // 0x00
+	'&',  '*',  '(',  ')',  '_',  '+',  '\b', '\t',
+	'Q',  'W',  'E',  'R',  'T',  'Y',  'U',  'I',  // 0x10
+	'O',  'P',  '{',  '}',  '\n', NO,   'A',  'S',
+	'D',  'F',  'G',  'H',  'J',  'K',  'L',  ':',  // 0x20
+	'"',  '~',  NO,   '|',  'Z',  'X',  'C',  'V',
+	'B',  'N',  'M',  '<',  '>',  '?',  NO,   '*',  // 0x30
+	NO,   ' ',  NO,   NO,   NO,   NO,   NO,   NO,
+	NO,   NO,   NO,   NO,   NO,   NO,   NO,   '7',  // 0x40
+	'8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',
+	'2',  '3',  '0',  '.',  NO,   NO,   NO,   NO,   // 0x50
+	[0x9C] '\n',      // KP_Enter
+	[0xB5] '/',       // KP_Div
+	[0xC8] KEY_UP,    [0xD0] KEY_DN,
+	[0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
+	[0xCB] KEY_LF,    [0xCD] KEY_RT,
+	[0x97] KEY_HOME,  [0xCF] KEY_END,
+	[0xD2] KEY_INS,   [0xD3] KEY_DEL
+};
+
+static uchar ctlmap[256] = {
+	NO,      NO,      NO,      NO,      NO,      NO,      NO,      NO,
+	NO,      NO,      NO,      NO,      NO,      NO,      NO,      NO,
+	C('Q'),  C('W'),  C('E'),  C('R'),  C('T'),  C('Y'),  C('U'),  C('I'),
+	C('O'),  C('P'),  NO,      NO,      '\r',    NO,      C('A'),  C('S'),
+	C('D'),  C('F'),  C('G'),  C('H'),  C('J'),  C('K'),  C('L'),  NO,
+	NO,      NO,      NO,      C('\\'), C('Z'),  C('X'),  C('C'),  C('V'),
+	C('B'),  C('N'),  C('M'),  NO,      NO,      C('/'),  NO,      NO,
+	[0x9C] '\r',      // KP_Enter
+	[0xB5] C('/'),    // KP_Div
+	[0xC8] KEY_UP,    [0xD0] KEY_DN,
+	[0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
+	[0xCB] KEY_LF,    [0xCD] KEY_RT,
+	[0x97] KEY_HOME,  [0xCF] KEY_END,
+	[0xD2] KEY_INS,   [0xD3] KEY_DEL
+};
+
diff --git a/include/kernel/memlayout.h b/include/kernel/memlayout.h
new file mode 100644
index 0000000..fcc7b91
--- /dev/null
+++ b/include/kernel/memlayout.h
@@ -0,0 +1,26 @@
+// Memory layout
+
+#define EXTMEM  0x100000            // Start of extended memory
+#define PHYSTOP 0xE000000           // Top physical memory
+#define DEVSPACE 0xFE000000         // Other devices are at high addresses
+
+// Key addresses for address space layout (see kmap in vm.c for layout)
+#define KERNBASE 0x80000000         // First kernel virtual address
+#define KERNLINK (KERNBASE+EXTMEM)  // Address where kernel is linked
+
+#ifndef __ASSEMBLER__
+
+static inline uint v2p(void *a) {
+	return ((uint)(a))  - KERNBASE;
+}
+static inline void *p2v(uint a) {
+	return (void *)((a) + KERNBASE);
+}
+
+#endif
+
+#define V2P(a) (((uint) (a)) - KERNBASE)
+#define P2V(a) (((void *) (a)) + KERNBASE)
+
+#define V2P_WO(x) ((x) - KERNBASE)    // same as V2P, but without casts
+#define P2V_WO(x) ((x) + KERNBASE)    // same as V2P, but without casts
diff --git a/include/kernel/mmu.h b/include/kernel/mmu.h
new file mode 100644
index 0000000..269a2fb
--- /dev/null
+++ b/include/kernel/mmu.h
@@ -0,0 +1,226 @@
+// This file contains definitions for the
+// x86 memory management unit (MMU).
+
+// Eflags register
+#define FL_CF           0x00000001      // Carry Flag
+#define FL_PF           0x00000004      // Parity Flag
+#define FL_AF           0x00000010      // Auxiliary carry Flag
+#define FL_ZF           0x00000040      // Zero Flag
+#define FL_SF           0x00000080      // Sign Flag
+#define FL_TF           0x00000100      // Trap Flag
+#define FL_IF           0x00000200      // Interrupt Enable
+#define FL_DF           0x00000400      // Direction Flag
+#define FL_OF           0x00000800      // Overflow Flag
+#define FL_IOPL_MASK    0x00003000      // I/O Privilege Level bitmask
+#define FL_IOPL_0       0x00000000      //   IOPL == 0
+#define FL_IOPL_1       0x00001000      //   IOPL == 1
+#define FL_IOPL_2       0x00002000      //   IOPL == 2
+#define FL_IOPL_3       0x00003000      //   IOPL == 3
+#define FL_NT           0x00004000      // Nested Task
+#define FL_RF           0x00010000      // Resume Flag
+#define FL_VM           0x00020000      // Virtual 8086 mode
+#define FL_AC           0x00040000      // Alignment Check
+#define FL_VIF          0x00080000      // Virtual Interrupt Flag
+#define FL_VIP          0x00100000      // Virtual Interrupt Pending
+#define FL_ID           0x00200000      // ID flag
+
+// Control Register flags
+#define CR0_PE          0x00000001      // Protection Enable
+#define CR0_MP          0x00000002      // Monitor coProcessor
+#define CR0_EM          0x00000004      // Emulation
+#define CR0_TS          0x00000008      // Task Switched
+#define CR0_ET          0x00000010      // Extension Type
+#define CR0_NE          0x00000020      // Numeric Errror
+#define CR0_WP          0x00010000      // Write Protect
+#define CR0_AM          0x00040000      // Alignment Mask
+#define CR0_NW          0x20000000      // Not Writethrough
+#define CR0_CD          0x40000000      // Cache Disable
+#define CR0_PG          0x80000000      // Paging
+
+#define CR4_PSE         0x00000010      // Page size extension
+
+#define SEG_KCODE 1  // kernel code
+#define SEG_KDATA 2  // kernel data+stack
+#define SEG_KCPU  3  // kernel per-cpu data
+#define SEG_UCODE 4  // user code
+#define SEG_UDATA 5  // user data+stack
+#define SEG_TSS   6  // this process's task state
+
+//PAGEBREAK!
+#ifndef __ASSEMBLER__
+// Segment Descriptor
+struct segdesc {
+	uint lim_15_0 : 16;  // Low bits of segment limit
+	uint base_15_0 : 16; // Low bits of segment base address
+	uint base_23_16 : 8; // Middle bits of segment base address
+	uint type : 4;       // Segment type (see STS_ constants)
+	uint s : 1;          // 0 = system, 1 = application
+	uint dpl : 2;        // Descriptor Privilege Level
+	uint p : 1;          // Present
+	uint lim_19_16 : 4;  // High bits of segment limit
+	uint avl : 1;        // Unused (available for software use)
+	uint rsv1 : 1;       // Reserved
+	uint db : 1;         // 0 = 16-bit segment, 1 = 32-bit segment
+	uint g : 1;          // Granularity: limit scaled by 4K when set
+	uint base_31_24 : 8; // High bits of segment base address
+};
+
+// Normal segment
+#define SEG(type, base, lim, dpl) (struct segdesc)    \
+{ ((lim) >> 12) & 0xffff, (uint)(base) & 0xffff,      \
+  ((uint)(base) >> 16) & 0xff, type, 1, dpl, 1,       \
+  (uint)(lim) >> 28, 0, 0, 1, 1, (uint)(base) >> 24 }
+#define SEG16(type, base, lim, dpl) (struct segdesc)  \
+{ (lim) & 0xffff, (uint)(base) & 0xffff,              \
+  ((uint)(base) >> 16) & 0xff, type, 1, dpl, 1,       \
+  (uint)(lim) >> 16, 0, 0, 1, 0, (uint)(base) >> 24 }
+#endif
+
+#define DPL_USER    0x3     // User DPL
+
+// Application segment type bits
+#define STA_X       0x8     // Executable segment
+#define STA_E       0x4     // Expand down (non-executable segments)
+#define STA_C       0x4     // Conforming code segment (executable only)
+#define STA_W       0x2     // Writeable (non-executable segments)
+#define STA_R       0x2     // Readable (executable segments)
+#define STA_A       0x1     // Accessed
+
+// System segment type bits
+#define STS_T16A    0x1     // Available 16-bit TSS
+#define STS_LDT     0x2     // Local Descriptor Table
+#define STS_T16B    0x3     // Busy 16-bit TSS
+#define STS_CG16    0x4     // 16-bit Call Gate
+#define STS_TG      0x5     // Task Gate / Coum Transmitions
+#define STS_IG16    0x6     // 16-bit Interrupt Gate
+#define STS_TG16    0x7     // 16-bit Trap Gate
+#define STS_T32A    0x9     // Available 32-bit TSS
+#define STS_T32B    0xB     // Busy 32-bit TSS
+#define STS_CG32    0xC     // 32-bit Call Gate
+#define STS_IG32    0xE     // 32-bit Interrupt Gate
+#define STS_TG32    0xF     // 32-bit Trap Gate
+
+// A virtual address 'la' has a three-part structure as follows:
+//
+// +--------10------+-------10-------+---------12----------+
+// | Page Directory |   Page Table   | Offset within Page  |
+// |      Index     |      Index     |                     |
+// +----------------+----------------+---------------------+
+//  \--- PDX(va) --/ \--- PTX(va) --/
+
+// page directory index
+#define PDX(va)         (((uint)(va) >> PDXSHIFT) & 0x3FF)
+
+// page table index
+#define PTX(va)         (((uint)(va) >> PTXSHIFT) & 0x3FF)
+
+// construct virtual address from indexes and offset
+#define PGADDR(d, t, o) ((uint)((d) << PDXSHIFT | (t) << PTXSHIFT | (o)))
+
+// Page directory and page table constants.
+#define NPDENTRIES      1024    // # directory entries per page directory
+#define NPTENTRIES      1024    // # PTEs per page table
+#define PGSIZE          4096    // bytes mapped by a page
+
+#define PGSHIFT         12      // log2(PGSIZE)
+#define PTXSHIFT        12      // offset of PTX in a linear address
+#define PDXSHIFT        22      // offset of PDX in a linear address
+
+#define PGROUNDUP(sz)  (((sz)+PGSIZE-1) & ~(PGSIZE-1))
+#define PGROUNDDOWN(a) (((a)) & ~(PGSIZE-1))
+
+// Page table/directory entry flags.
+#define PTE_P           0x001   // Present
+#define PTE_W           0x002   // Writeable
+#define PTE_U           0x004   // User
+#define PTE_PWT         0x008   // Write-Through
+#define PTE_PCD         0x010   // Cache-Disable
+#define PTE_A           0x020   // Accessed
+#define PTE_D           0x040   // Dirty
+#define PTE_PS          0x080   // Page Size
+#define PTE_MBZ         0x180   // Bits must be zero
+
+// Address in page table or page directory entry
+#define PTE_ADDR(pte)   ((uint)(pte) & ~0xFFF)
+#define PTE_FLAGS(pte)  ((uint)(pte) &  0xFFF)
+
+#ifndef __ASSEMBLER__
+typedef uint pte_t;
+
+// Task state segment format
+struct taskstate {
+	uint link;         // Old ts selector
+	uint esp0;         // Stack pointers and segment selectors
+	ushort ss0;        //   after an increase in privilege level
+	ushort padding1;
+	uint *esp1;
+	ushort ss1;
+	ushort padding2;
+	uint *esp2;
+	ushort ss2;
+	ushort padding3;
+	void *cr3;         // Page directory base
+	uint *eip;         // Saved state from last task switch
+	uint eflags;
+	uint eax;          // More saved state (registers)
+	uint ecx;
+	uint edx;
+	uint ebx;
+	uint *esp;
+	uint *ebp;
+	uint esi;
+	uint edi;
+	ushort es;         // Even more saved state (segment selectors)
+	ushort padding4;
+	ushort cs;
+	ushort padding5;
+	ushort ss;
+	ushort padding6;
+	ushort ds;
+	ushort padding7;
+	ushort fs;
+	ushort padding8;
+	ushort gs;
+	ushort padding9;
+	ushort ldt;
+	ushort padding10;
+	ushort t;          // Trap on task switch
+	ushort iomb;       // I/O map base address
+};
+
+// PAGEBREAK: 12
+// Gate descriptors for interrupts and traps
+struct gatedesc {
+	uint off_15_0 : 16;   // low 16 bits of offset in segment
+	uint cs : 16;         // code segment selector
+	uint args : 5;        // # args, 0 for interrupt/trap gates
+	uint rsv1 : 3;        // reserved(should be zero I guess)
+	uint type : 4;        // type(STS_{TG,IG32,TG32})
+	uint s : 1;           // must be 0 (system)
+	uint dpl : 2;         // descriptor(meaning new) privilege level
+	uint p : 1;           // Present
+	uint off_31_16 : 16;  // high bits of offset in segment
+};
+
+// Set up a normal interrupt/trap gate descriptor.
+// - istrap: 1 for a trap (= exception) gate, 0 for an interrupt gate.
+//   interrupt gate clears FL_IF, trap gate leaves FL_IF alone
+// - sel: Code segment selector for interrupt/trap handler
+// - off: Offset in code segment for interrupt/trap handler
+// - dpl: Descriptor Privilege Level -
+//        the privilege level required for software to invoke
+//        this interrupt/trap gate explicitly using an int instruction.
+#define SETGATE(gate, istrap, sel, off, d)                \
+{                                                         \
+  (gate).off_15_0 = (uint)(off) & 0xffff;                \
+  (gate).cs = (sel);                                      \
+  (gate).args = 0;                                        \
+  (gate).rsv1 = 0;                                        \
+  (gate).type = (istrap) ? STS_TG32 : STS_IG32;           \
+  (gate).s = 0;                                           \
+  (gate).dpl = (d);                                       \
+  (gate).p = 1;                                           \
+  (gate).off_31_16 = (uint)(off) >> 16;                  \
+}
+
+#endif
diff --git a/include/kernel/mp.h b/include/kernel/mp.h
new file mode 100644
index 0000000..47c90b3
--- /dev/null
+++ b/include/kernel/mp.h
@@ -0,0 +1,54 @@
+// See MultiProcessor Specification Version 1.[14]
+
+struct mp {             // floating pointer
+	uchar signature[4];           // "_MP_"
+	void *physaddr;               // phys addr of MP config table
+	uchar length;                 // 1
+	uchar specrev;                // [14]
+	uchar checksum;               // all bytes must add up to 0
+	uchar type;                   // MP system config type
+	uchar imcrp;
+	uchar reserved[3];
+};
+
+struct mpconf {         // configuration table header
+	uchar signature[4];           // "PCMP"
+	ushort length;                // total table length
+	uchar version;                // [14]
+	uchar checksum;               // all bytes must add up to 0
+	uchar product[20];            // product id
+	uint *oemtable;               // OEM table pointer
+	ushort oemlength;             // OEM table length
+	ushort entry;                 // entry count
+	uint *lapicaddr;              // address of local APIC
+	ushort xlength;               // extended table length
+	uchar xchecksum;              // extended table checksum
+	uchar reserved;
+};
+
+struct mpproc {         // processor table entry
+	uchar type;                   // entry type (0)
+	uchar apicid;                 // local APIC id
+	uchar version;                // local APIC verison
+	uchar flags;                  // CPU flags
+#define MPBOOT 0x02           // This proc is the bootstrap processor.
+	uchar signature[4];           // CPU signature
+	uint feature;                 // feature flags from CPUID instruction
+	uchar reserved[8];
+};
+
+struct mpioapic {       // I/O APIC table entry
+	uchar type;                   // entry type (2)
+	uchar apicno;                 // I/O APIC id
+	uchar version;                // I/O APIC version
+	uchar flags;                  // I/O APIC flags
+	uint *addr;                  // I/O APIC address
+};
+
+// Table entry types
+#define MPPROC    0x00  // One per processor
+#define MPBUS     0x01  // One per bus
+#define MPIOAPIC  0x02  // One per I/O APIC
+#define MPIOINTR  0x03  // One per bus interrupt source
+#define MPLINTR   0x04  // One per system interrupt source
+
diff --git a/include/kernel/param.h b/include/kernel/param.h
new file mode 100644
index 0000000..b6f6f46
--- /dev/null
+++ b/include/kernel/param.h
@@ -0,0 +1,12 @@
+#define NPROC        64  // maximum number of processes
+#define KSTACKSIZE 4096  // size of per-process kernel stack
+#define NCPU          8  // maximum number of CPUs
+#define NOFILE       16  // open files per process
+#define NFILE       100  // open files per system
+#define NBUF         10  // size of disk block cache
+#define NINODE       50  // maximum number of active i-nodes
+#define NDEV         10  // maximum major device number
+#define ROOTDEV       1  // device number of file system root disk
+#define MAXARG       32  // max exec arguments
+#define LOGSIZE      10  // max data sectors in on-disk log
+
diff --git a/include/kernel/proc.h b/include/kernel/proc.h
new file mode 100644
index 0000000..4ca33cb
--- /dev/null
+++ b/include/kernel/proc.h
@@ -0,0 +1,75 @@
+// Segments in proc->gdt.
+#define NSEGS     7
+
+// Per-CPU state
+struct cpu {
+	uchar id;                    // Local APIC ID; index into cpus[] below
+	struct context *scheduler;   // swtch() here to enter scheduler
+	struct taskstate ts;         // Used by x86 to find stack for interrupt
+	struct segdesc gdt[NSEGS];   // x86 global descriptor table
+	volatile uint started;       // Has the CPU started?
+	int ncli;                    // Depth of pushcli nesting.
+	int intena;                  // Were interrupts enabled before pushcli?
+
+	// Cpu-local storage variables; see below
+	struct cpu *cpu;
+	struct proc *proc;           // The currently-running process.
+};
+
+extern struct cpu cpus[NCPU];
+extern int ncpu;
+
+// Per-CPU variables, holding pointers to the
+// current cpu and to the current process.
+// The asm suffix tells gcc to use "%gs:0" to refer to cpu
+// and "%gs:4" to refer to proc.  seginit sets up the
+// %gs segment register so that %gs refers to the memory
+// holding those two variables in the local cpu's struct cpu.
+// This is similar to how thread-local variables are implemented
+// in thread libraries such as Linux pthreads.
+extern struct cpu *cpu asm("%gs:0");       // &cpus[cpunum()]
+extern struct proc *proc asm("%gs:4");     // cpus[cpunum()].proc
+
+//PAGEBREAK: 17
+// Saved registers for kernel context switches.
+// Don't need to save all the segment registers (%cs, etc),
+// because they are constant across kernel contexts.
+// Don't need to save %eax, %ecx, %edx, because the
+// x86 convention is that the caller has saved them.
+// Contexts are stored at the bottom of the stack they
+// describe; the stack pointer is the address of the context.
+// The layout of the context matches the layout of the stack in swtch.S
+// at the "Switch stacks" comment. Switch doesn't save eip explicitly,
+// but it is on the stack and allocproc() manipulates it.
+struct context {
+	uint edi;
+	uint esi;
+	uint ebx;
+	uint ebp;
+	uint eip;
+};
+
+enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
+
+// Per-process state
+struct proc {
+	uint sz;                     // Size of process memory (bytes)
+	pde_t *pgdir;                // Page table
+	char *kstack;                // Bottom of kernel stack for this process
+	enum procstate state;        // Process state
+	volatile int pid;            // Process ID
+	struct proc *parent;         // Parent process
+	struct trapframe *tf;        // Trap frame for current syscall
+	struct context *context;     // swtch() here to run process
+	void *chan;                  // If non-zero, sleeping on chan
+	int killed;                  // If non-zero, have been killed
+	struct file *ofile[NOFILE];  // Open files
+	struct inode *cwd;           // Current directory
+	char name[16];               // Process name (debugging)
+};
+
+// Process memory is laid out contiguously, low addresses first:
+//   text
+//   original data and bss
+//   fixed-size stack
+//   expandable heap
diff --git a/include/kernel/spinlock.h b/include/kernel/spinlock.h
new file mode 100644
index 0000000..ed320ac
--- /dev/null
+++ b/include/kernel/spinlock.h
@@ -0,0 +1,11 @@
+// Mutual exclusion lock.
+struct spinlock {
+	uint locked;       // Is the lock held?
+
+	// For debugging:
+	char *name;        // Name of lock.
+	struct cpu *cpu;   // The cpu holding the lock.
+	uint pcs[10];      // The call stack (an array of program counters)
+	// that locked the lock.
+};
+
diff --git a/include/kernel/stat.h b/include/kernel/stat.h
new file mode 100644
index 0000000..7d82387
--- /dev/null
+++ b/include/kernel/stat.h
@@ -0,0 +1,11 @@
+#define T_DIR  1   // Directory
+#define T_FILE 2   // File
+#define T_DEV  3   // Device
+
+struct stat {
+	short type;  // Type of file
+	int dev;     // File system's disk device
+	uint ino;    // Inode number
+	short nlink; // Number of links to file
+	uint size;   // Size of file in bytes
+};
diff --git a/include/kernel/syscall.h b/include/kernel/syscall.h
new file mode 100644
index 0000000..218eeb0
--- /dev/null
+++ b/include/kernel/syscall.h
@@ -0,0 +1,25 @@
+// System call numbers
+#define SYS_fork    1
+#define SYS_exit    2
+#define SYS_wait    3
+#define SYS_pipe    4
+#define SYS_read    5
+#define SYS_kill    6
+#define SYS_execve  7
+#define SYS_fstat   8
+#define SYS_chdir   9
+#define SYS_dup    10
+#define SYS_getpid 11
+#define SYS_sbrk   12
+#define SYS_sleep  13
+#define SYS_uptime 14
+#define SYS_open   15
+#define SYS_write  16
+#define SYS_mknod  17
+#define SYS_unlink 18
+#define SYS_link   19
+#define SYS_mkdir  20
+#define SYS_close  21
+
+#define SYS_tell 22
+#define SYS_seek 23
diff --git a/include/kernel/traps.h b/include/kernel/traps.h
new file mode 100644
index 0000000..0bd1fd8
--- /dev/null
+++ b/include/kernel/traps.h
@@ -0,0 +1,38 @@
+// x86 trap and interrupt constants.
+
+// Processor-defined:
+#define T_DIVIDE         0      // divide error
+#define T_DEBUG          1      // debug exception
+#define T_NMI            2      // non-maskable interrupt
+#define T_BRKPT          3      // breakpoint
+#define T_OFLOW          4      // overflow
+#define T_BOUND          5      // bounds check
+#define T_ILLOP          6      // illegal opcode
+#define T_DEVICE         7      // device not available
+#define T_DBLFLT         8      // double fault
+// #define T_COPROC      9      // reserved (not used since 486)
+#define T_TSS           10      // invalid task switch segment
+#define T_SEGNP         11      // segment not present
+#define T_STACK         12      // stack exception
+#define T_GPFLT         13      // general protection fault
+#define T_PGFLT         14      // page fault
+// #define T_RES        15      // reserved
+#define T_FPERR         16      // floating point error
+#define T_ALIGN         17      // aligment check
+#define T_MCHK          18      // machine check
+#define T_SIMDERR       19      // SIMD floating point error
+
+// These are arbitrarily chosen, but with care not to overlap
+// processor defined exceptions or interrupt vectors.
+#define T_SYSCALL       64      // system call
+#define T_DEFAULT      500      // catchall
+
+#define T_IRQ0          32      // IRQ 0 corresponds to int T_IRQ
+
+#define IRQ_TIMER        0
+#define IRQ_KBD          1
+#define IRQ_COM1         4
+#define IRQ_IDE         14
+#define IRQ_ERROR       19
+#define IRQ_SPURIOUS    31
+
diff --git a/include/kernel/types.h b/include/kernel/types.h
new file mode 100644
index 0000000..e4adf64
--- /dev/null
+++ b/include/kernel/types.h
@@ -0,0 +1,4 @@
+typedef unsigned int   uint;
+typedef unsigned short ushort;
+typedef unsigned char  uchar;
+typedef uint pde_t;
diff --git a/include/kernel/x86.h b/include/kernel/x86.h
new file mode 100644
index 0000000..76b76ad
--- /dev/null
+++ b/include/kernel/x86.h
@@ -0,0 +1,166 @@
+// Routines to let C code use special x86 instructions.
+
+static inline uchar
+inb(ushort port) {
+	uchar data;
+
+	asm volatile("in %1,%0" : "=a"(data) : "d"(port));
+	return data;
+}
+
+static inline void
+insl(int port, void *addr, int cnt) {
+	asm volatile("cld; rep insl" :
+				 "=D"(addr), "=c"(cnt) :
+				 "d"(port), "0"(addr), "1"(cnt) :
+				 "memory", "cc");
+}
+
+static inline void
+outb(ushort port, uchar data) {
+	asm volatile("out %0,%1" : : "a"(data), "d"(port));
+}
+
+static inline void
+outw(ushort port, ushort data) {
+	asm volatile("out %0,%1" : : "a"(data), "d"(port));
+}
+
+static inline void
+outsl(int port, const void *addr, int cnt) {
+	asm volatile("cld; rep outsl" :
+				 "=S"(addr), "=c"(cnt) :
+				 "d"(port), "0"(addr), "1"(cnt) :
+				 "cc");
+}
+
+static inline void
+stosb(void *addr, int data, int cnt) {
+	asm volatile("cld; rep stosb" :
+				 "=D"(addr), "=c"(cnt) :
+				 "0"(addr), "1"(cnt), "a"(data) :
+				 "memory", "cc");
+}
+
+static inline void
+stosl(void *addr, int data, int cnt) {
+	asm volatile("cld; rep stosl" :
+				 "=D"(addr), "=c"(cnt) :
+				 "0"(addr), "1"(cnt), "a"(data) :
+				 "memory", "cc");
+}
+
+struct segdesc;
+
+static inline void
+lgdt(struct segdesc *p, int size) {
+	volatile ushort pd[3];
+
+	pd[0] = size - 1;
+	pd[1] = (uint)p;
+	pd[2] = (uint)p >> 16;
+
+	asm volatile("lgdt (%0)" : : "r"(pd));
+}
+
+struct gatedesc;
+
+static inline void
+lidt(struct gatedesc *p, int size) {
+	volatile ushort pd[3];
+
+	pd[0] = size - 1;
+	pd[1] = (uint)p;
+	pd[2] = (uint)p >> 16;
+
+	asm volatile("lidt (%0)" : : "r"(pd));
+}
+
+static inline void
+ltr(ushort sel) {
+	asm volatile("ltr %0" : : "r"(sel));
+}
+
+static inline uint
+readeflags(void) {
+	uint eflags;
+	asm volatile("pushfl; popl %0" : "=r"(eflags));
+	return eflags;
+}
+
+static inline void
+loadgs(ushort v) {
+	asm volatile("movw %0, %%gs" : : "r"(v));
+}
+
+static inline void
+cli(void) {
+	asm volatile("cli");
+}
+
+static inline void
+sti(void) {
+	asm volatile("sti");
+}
+
+static inline uint
+xchg(volatile uint *addr, uint newval) {
+	uint result;
+
+	// The + in "+m" denotes a read-modify-write operand.
+	asm volatile("lock; xchgl %0, %1" :
+				 "+m"(*addr), "=a"(result) :
+				 "1"(newval) :
+				 "cc");
+	return result;
+}
+
+static inline uint
+rcr2(void) {
+	uint val;
+	asm volatile("movl %%cr2,%0" : "=r"(val));
+	return val;
+}
+
+static inline void
+lcr3(uint val) {
+	asm volatile("movl %0,%%cr3" : : "r"(val));
+}
+
+//PAGEBREAK: 36
+// Layout of the trap frame built on the stack by the
+// hardware and by trapasm.S, and passed to trap().
+struct trapframe {
+	// registers as pushed by pusha
+	uint edi;
+	uint esi;
+	uint ebp;
+	uint oesp;      // useless & ignored
+	uint ebx;
+	uint edx;
+	uint ecx;
+	uint eax;
+
+	// rest of trap frame
+	ushort gs;
+	ushort padding1;
+	ushort fs;
+	ushort padding2;
+	ushort es;
+	ushort padding3;
+	ushort ds;
+	ushort padding4;
+	uint trapno;
+
+	// below here defined by x86 hardware
+	uint err;
+	uint eip;
+	ushort cs;
+	ushort padding5;
+	uint eflags;
+
+	// below here only when crossing rings, such as from user to kernel
+	uint esp;
+	ushort ss;
+	ushort padding6;
+};
diff --git a/include/sys/asm.h b/include/sys/asm.h
deleted file mode 100644
index 68210d7..0000000
--- a/include/sys/asm.h
+++ /dev/null
@@ -1,21 +0,0 @@
-//
-// assembler macros to create x86 segments
-//
-
-#define SEG_NULLASM                                             \
-        .word 0, 0;                                             \
-        .byte 0, 0, 0, 0
-
-// The 0xC0 means the limit is in 4096-byte units
-// and (for executable segments) 32-bit mode.
-#define SEG_ASM(type,base,lim)                                  \
-        .word (((lim) >> 12) & 0xffff), ((base) & 0xffff);      \
-        .byte (((base) >> 16) & 0xff), (0x90 | (type)),         \
-                (0xC0 | (((lim) >> 28) & 0xf)), (((base) >> 24) & 0xff)
-
-#define STA_X     0x8       // Executable segment
-#define STA_E     0x4       // Expand down (non-executable segments)
-#define STA_C     0x4       // Conforming code segment (executable only)
-#define STA_W     0x2       // Writeable (non-executable segments)
-#define STA_R     0x2       // Readable (executable segments)
-#define STA_A     0x1       // Accessed
diff --git a/include/sys/buf.h b/include/sys/buf.h
deleted file mode 100644
index e7357f0..0000000
--- a/include/sys/buf.h
+++ /dev/null
@@ -1,13 +0,0 @@
-struct buf {
-	int flags;
-	uint dev;
-	uint sector;
-	struct buf *prev; // LRU cache list
-	struct buf *next;
-	struct buf *qnext; // disk queue
-	uchar data[512];
-};
-#define B_BUSY  0x1  // buffer is locked by some process
-#define B_VALID 0x2  // buffer has been read from disk
-#define B_DIRTY 0x4  // buffer needs to be written to disk
-
diff --git a/include/sys/defs.h b/include/sys/defs.h
deleted file mode 100644
index 0b5223b..0000000
--- a/include/sys/defs.h
+++ /dev/null
@@ -1,181 +0,0 @@
-struct buf;
-struct context;
-struct file;
-struct inode;
-struct pipe;
-struct proc;
-struct spinlock;
-struct stat;
-struct superblock;
-
-// bio.c
-void            binit(void);
-struct buf     *bread(uint, uint);
-void            brelse(struct buf *);
-void            bwrite(struct buf *);
-
-// console.c
-void            consoleinit(void);
-void            cprintf(const char *, ...);
-void            consoleintr(int( *)(void));
-void            panic(const char *) __attribute__((noreturn));
-
-// exec.c
-int             exec(char *, char **);
-
-// file.c
-struct file    *filealloc(void);
-void            fileclose(struct file *);
-struct file    *filedup(struct file *);
-void            fileinit(void);
-int             fileread(struct file *, char *, int n);
-int             filestat(struct file *, struct stat *);
-int             filewrite(struct file *, char *, int n);
-
-// fs.c
-void            readsb(int dev, struct superblock *sb);
-int             dirlink(struct inode *, char *, uint);
-struct inode   *dirlookup(struct inode *, char *, uint *);
-struct inode   *ialloc(uint, short);
-struct inode   *idup(struct inode *);
-void            iinit(void);
-void            ilock(struct inode *);
-void            iput(struct inode *);
-void            iunlock(struct inode *);
-void            iunlockput(struct inode *);
-void            iupdate(struct inode *);
-int             namecmp(const char *, const char *);
-struct inode   *namei(char *);
-struct inode   *nameiparent(char *, char *);
-int             readi(struct inode *, char *, uint, uint);
-void            stati(struct inode *, struct stat *);
-int             writei(struct inode *, char *, uint, uint);
-
-// ide.c
-void            ideinit(void);
-void            ideintr(void);
-void            iderw(struct buf *);
-
-// ioapic.c
-void            ioapicenable(int irq, int cpu);
-extern uchar    ioapicid;
-void            ioapicinit(void);
-
-// kalloc.c
-char           *kalloc(void);
-void            kfree(char *);
-void            kinit1(void *, void *);
-void            kinit2(void *, void *);
-
-// kbd.c
-void            kbdintr(void);
-
-// lapic.c
-int             cpunum(void);
-extern volatile uint    *lapic;
-void            lapiceoi(void);
-void            lapicinit(void);
-void            lapicstartap(uchar, uint);
-void            microdelay(int);
-
-// log.c
-void            initlog(void);
-void            log_write(struct buf *);
-void            begin_trans();
-void            commit_trans();
-
-// mp.c
-extern int      ismp;
-int             mpbcpu(void);
-void            mpinit(void);
-void            mpstartthem(void);
-
-// picirq.c
-void            picenable(int);
-void            picinit(void);
-
-// pipe.c
-int             pipealloc(struct file **, struct file **);
-void            pipeclose(struct pipe *, int);
-int             piperead(struct pipe *, char *, int);
-int             pipewrite(struct pipe *, char *, int);
-
-//PAGEBREAK: 16
-// proc.c
-struct proc    *copyproc(struct proc *);
-void            exit(void);
-int             fork(void);
-int             growproc(int);
-int             kill(int);
-void            pinit(void);
-void            procdump(void);
-void            scheduler(void) __attribute__((noreturn));
-void            sched(void);
-void            sleep(void *, struct spinlock *);
-void            userinit(void);
-int             wait(void);
-void            wakeup(void *);
-void            yield(void);
-
-// swtch.S
-void            swtch(struct context **, struct context *);
-
-// spinlock.c
-void            acquire(struct spinlock *);
-void            getcallerpcs(void *, uint *);
-int             holding(struct spinlock *);
-void            initlock(struct spinlock *, const char *);
-void            release(struct spinlock *);
-void            pushcli(void);
-void            popcli(void);
-
-// string.c
-int             memcmp(const void *, const void *, uint);
-void           *memmove(void *, const void *, uint);
-void           *memset(void *, int, uint);
-char           *safestrcpy(char *, const char *, int);
-int             strlen(const char *);
-int             strncmp(const char *, const char *, uint);
-char           *strncpy(char *, const char *, int);
-
-// syscall.c
-int             argint(int, int *);
-int             argptr(int, char **, int);
-int             argstr(int, char **);
-int             fetchint(uint, int *);
-int             fetchstr(uint, char **);
-void            syscall(void);
-
-// timer.c
-void            timerinit(void);
-
-// trap.c
-void            idtinit(void);
-extern uint     ticks;
-void            tvinit(void);
-extern struct spinlock tickslock;
-
-// uart.c
-void            uartinit(void);
-void            uartintr(void);
-void            uartputc(int);
-
-// vm.c
-void            seginit(void);
-void            kvmalloc(void);
-void            vmenable(void);
-pde_t          *setupkvm(void);
-char           *uva2ka(pde_t *, char *);
-int             allocuvm(pde_t *, uint, uint);
-int             deallocuvm(pde_t *, uint, uint);
-void            freevm(pde_t *);
-void            inituvm(pde_t *, char *, uint);
-int             loaduvm(pde_t *, char *, struct inode *, uint, uint);
-pde_t          *copyuvm(pde_t *, uint);
-void            switchuvm(struct proc *);
-void            switchkvm(void);
-int             copyout(pde_t *, uint, void *, uint);
-void            clearpteu(pde_t *pgdir, char *uva);
-
-// number of elements in fixed-size array
-#define NELEM(x) (sizeof(x)/sizeof((x)[0]))
diff --git a/include/sys/elf.h b/include/sys/elf.h
deleted file mode 100644
index acf24b4..0000000
--- a/include/sys/elf.h
+++ /dev/null
@@ -1,42 +0,0 @@
-// Format of an ELF executable file
-
-#define ELF_MAGIC 0x464C457FU  // "\x7FELF" in little endian
-
-// File header
-struct elfhdr {
-	uint magic;  // must equal ELF_MAGIC
-	uchar elf[12];
-	ushort type;
-	ushort machine;
-	uint version;
-	uint entry;
-	uint phoff;
-	uint shoff;
-	uint flags;
-	ushort ehsize;
-	ushort phentsize;
-	ushort phnum;
-	ushort shentsize;
-	ushort shnum;
-	ushort shstrndx;
-};
-
-// Program section header
-struct proghdr {
-	uint type;
-	uint off;
-	uint vaddr;
-	uint paddr;
-	uint filesz;
-	uint memsz;
-	uint flags;
-	uint align;
-};
-
-// Values for Proghdr type
-#define ELF_PROG_LOAD           1
-
-// Flag bits for Proghdr flags
-#define ELF_PROG_FLAG_EXEC      1
-#define ELF_PROG_FLAG_WRITE     2
-#define ELF_PROG_FLAG_READ      4
diff --git a/include/sys/fcntl.h b/include/sys/fcntl.h
index d565483..3ac7b2e 100644
--- a/include/sys/fcntl.h
+++ b/include/sys/fcntl.h
@@ -1,4 +1,4 @@
-#define O_RDONLY  0x000
-#define O_WRONLY  0x001
-#define O_RDWR    0x002
-#define O_CREATE  0x200
+#ifndef FCNTL_H
+#define FCNTL_H FCNTL_H
+#include <kernel/fcntl.h>
+#endif
diff --git a/include/sys/file.h b/include/sys/file.h
deleted file mode 100644
index 299d68f..0000000
--- a/include/sys/file.h
+++ /dev/null
@@ -1,38 +0,0 @@
-struct file {
-	enum { FD_NONE, FD_PIPE, FD_INODE } type;
-	int ref; // reference count
-	char readable;
-	char writable;
-	struct pipe *pipe;
-	struct inode *ip;
-	uint off;
-};
-
-
-// in-memory copy of an inode
-struct inode {
-	uint dev;           // Device number
-	uint inum;          // Inode number
-	int ref;            // Reference count
-	int flags;          // I_BUSY, I_VALID
-
-	short type;         // copy of disk inode
-	short major;
-	short minor;
-	short nlink;
-	uint size;
-	uint addrs[NDIRECT + 1];
-};
-#define I_BUSY 0x1
-#define I_VALID 0x2
-
-// table mapping major device number to
-// device functions
-struct devsw {
-	int (*read)(struct inode *, char *, int);
-	int (*write)(struct inode *, char *, int);
-};
-
-extern struct devsw devsw[];
-
-#define CONSOLE 1
diff --git a/include/sys/fs.h b/include/sys/fs.h
deleted file mode 100644
index 57c621b..0000000
--- a/include/sys/fs.h
+++ /dev/null
@@ -1,55 +0,0 @@
-// On-disk file system format.
-// Both the kernel and user programs use this header file.
-
-// Block 0 is unused.
-// Block 1 is super block.
-// Blocks 2 through sb.ninodes/IPB hold inodes.
-// Then free bitmap blocks holding sb.size bits.
-// Then sb.nblocks data blocks.
-// Then sb.nlog log blocks.
-
-#define ROOTINO 1  // root i-number
-#define BSIZE 512  // block size
-
-// File system super block
-struct superblock {
-	uint size;         // Size of file system image (blocks)
-	uint nblocks;      // Number of data blocks
-	uint ninodes;      // Number of inodes.
-	uint nlog;         // Number of log blocks
-};
-
-#define NDIRECT 12
-#define NINDIRECT (BSIZE / sizeof(uint))
-#define MAXFILE (NDIRECT + NINDIRECT)
-
-// On-disk inode structure
-struct dinode {
-	short type;           // File type
-	short major;          // Major device number (T_DEV only)
-	short minor;          // Minor device number (T_DEV only)
-	short nlink;          // Number of links to inode in file system
-	uint size;            // Size of file (bytes)
-	uint addrs[NDIRECT + 1]; // Data block addresses
-};
-
-// Inodes per block.
-#define IPB           (BSIZE / sizeof(struct dinode))
-
-// Block containing inode i
-#define IBLOCK(i)     ((i) / IPB + 2)
-
-// Bitmap bits per block
-#define BPB           (BSIZE*8)
-
-// Block containing bit for block b
-#define BBLOCK(b, ninodes) (b/BPB + (ninodes)/IPB + 3)
-
-// Directory is a file containing a sequence of dirent structures.
-#define DIRSIZ 14
-
-struct dirent {
-	ushort inum;
-	char name[DIRSIZ];
-};
-
diff --git a/include/sys/kbd.h b/include/sys/kbd.h
deleted file mode 100644
index 2d05329..0000000
--- a/include/sys/kbd.h
+++ /dev/null
@@ -1,107 +0,0 @@
-// PC keyboard interface constants
-
-#define KBSTATP         0x64    // kbd controller status port(I)
-#define KBS_DIB         0x01    // kbd data in buffer
-#define KBDATAP         0x60    // kbd data port(I)
-
-#define NO              0
-
-#define SHIFT           (1<<0)
-#define CTL             (1<<1)
-#define ALT             (1<<2)
-
-#define CAPSLOCK        (1<<3)
-#define NUMLOCK         (1<<4)
-#define SCROLLLOCK      (1<<5)
-
-#define E0ESC           (1<<6)
-
-// Special keycodes
-#define KEY_HOME        0xE0
-#define KEY_END         0xE1
-#define KEY_UP          0xE2
-#define KEY_DN          0xE3
-#define KEY_LF          0xE4
-#define KEY_RT          0xE5
-#define KEY_PGUP        0xE6
-#define KEY_PGDN        0xE7
-#define KEY_INS         0xE8
-#define KEY_DEL         0xE9
-
-// C('A') == Control-A
-#define C(x) (x - '@')
-
-static uchar shiftcode[256] = {
-	[0x1D] CTL,
-	[0x2A] SHIFT,
-	[0x36] SHIFT,
-	[0x38] ALT,
-	[0x9D] CTL,
-	[0xB8] ALT
-};
-
-static uchar togglecode[256] = {
-	[0x3A] CAPSLOCK,
-	[0x45] NUMLOCK,
-	[0x46] SCROLLLOCK
-};
-
-static uchar normalmap[256] = {
-	NO,   0x1B, '1',  '2',  '3',  '4',  '5',  '6',  // 0x00
-	'7',  '8',  '9',  '0',  '-',  '=',  '\b', '\t',
-	'q',  'w',  'e',  'r',  't',  'y',  'u',  'i',  // 0x10
-	'o',  'p',  '[',  ']',  '\n', NO,   'a',  's',
-	'd',  'f',  'g',  'h',  'j',  'k',  'l',  ';',  // 0x20
-	'\'', '`',  NO,   '\\', 'z',  'x',  'c',  'v',
-	'b',  'n',  'm',  ',',  '.',  '/',  NO,   '*',  // 0x30
-	NO,   ' ',  NO,   NO,   NO,   NO,   NO,   NO,
-	NO,   NO,   NO,   NO,   NO,   NO,   NO,   '7',  // 0x40
-	'8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',
-	'2',  '3',  '0',  '.',  NO,   NO,   NO,   NO,   // 0x50
-	[0x9C] '\n',      // KP_Enter
-	[0xB5] '/',       // KP_Div
-	[0xC8] KEY_UP,    [0xD0] KEY_DN,
-	[0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
-	[0xCB] KEY_LF,    [0xCD] KEY_RT,
-	[0x97] KEY_HOME,  [0xCF] KEY_END,
-	[0xD2] KEY_INS,   [0xD3] KEY_DEL
-};
-
-static uchar shiftmap[256] = {
-	NO,   033,  '!',  '@',  '#',  '$',  '%',  '^',  // 0x00
-	'&',  '*',  '(',  ')',  '_',  '+',  '\b', '\t',
-	'Q',  'W',  'E',  'R',  'T',  'Y',  'U',  'I',  // 0x10
-	'O',  'P',  '{',  '}',  '\n', NO,   'A',  'S',
-	'D',  'F',  'G',  'H',  'J',  'K',  'L',  ':',  // 0x20
-	'"',  '~',  NO,   '|',  'Z',  'X',  'C',  'V',
-	'B',  'N',  'M',  '<',  '>',  '?',  NO,   '*',  // 0x30
-	NO,   ' ',  NO,   NO,   NO,   NO,   NO,   NO,
-	NO,   NO,   NO,   NO,   NO,   NO,   NO,   '7',  // 0x40
-	'8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',
-	'2',  '3',  '0',  '.',  NO,   NO,   NO,   NO,   // 0x50
-	[0x9C] '\n',      // KP_Enter
-	[0xB5] '/',       // KP_Div
-	[0xC8] KEY_UP,    [0xD0] KEY_DN,
-	[0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
-	[0xCB] KEY_LF,    [0xCD] KEY_RT,
-	[0x97] KEY_HOME,  [0xCF] KEY_END,
-	[0xD2] KEY_INS,   [0xD3] KEY_DEL
-};
-
-static uchar ctlmap[256] = {
-	NO,      NO,      NO,      NO,      NO,      NO,      NO,      NO,
-	NO,      NO,      NO,      NO,      NO,      NO,      NO,      NO,
-	C('Q'),  C('W'),  C('E'),  C('R'),  C('T'),  C('Y'),  C('U'),  C('I'),
-	C('O'),  C('P'),  NO,      NO,      '\r',    NO,      C('A'),  C('S'),
-	C('D'),  C('F'),  C('G'),  C('H'),  C('J'),  C('K'),  C('L'),  NO,
-	NO,      NO,      NO,      C('\\'), C('Z'),  C('X'),  C('C'),  C('V'),
-	C('B'),  C('N'),  C('M'),  NO,      NO,      C('/'),  NO,      NO,
-	[0x9C] '\r',      // KP_Enter
-	[0xB5] C('/'),    // KP_Div
-	[0xC8] KEY_UP,    [0xD0] KEY_DN,
-	[0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
-	[0xCB] KEY_LF,    [0xCD] KEY_RT,
-	[0x97] KEY_HOME,  [0xCF] KEY_END,
-	[0xD2] KEY_INS,   [0xD3] KEY_DEL
-};
-
diff --git a/include/sys/memlayout.h b/include/sys/memlayout.h
deleted file mode 100644
index fcc7b91..0000000
--- a/include/sys/memlayout.h
+++ /dev/null
@@ -1,26 +0,0 @@
-// Memory layout
-
-#define EXTMEM  0x100000            // Start of extended memory
-#define PHYSTOP 0xE000000           // Top physical memory
-#define DEVSPACE 0xFE000000         // Other devices are at high addresses
-
-// Key addresses for address space layout (see kmap in vm.c for layout)
-#define KERNBASE 0x80000000         // First kernel virtual address
-#define KERNLINK (KERNBASE+EXTMEM)  // Address where kernel is linked
-
-#ifndef __ASSEMBLER__
-
-static inline uint v2p(void *a) {
-	return ((uint)(a))  - KERNBASE;
-}
-static inline void *p2v(uint a) {
-	return (void *)((a) + KERNBASE);
-}
-
-#endif
-
-#define V2P(a) (((uint) (a)) - KERNBASE)
-#define P2V(a) (((void *) (a)) + KERNBASE)
-
-#define V2P_WO(x) ((x) - KERNBASE)    // same as V2P, but without casts
-#define P2V_WO(x) ((x) + KERNBASE)    // same as V2P, but without casts
diff --git a/include/sys/mmu.h b/include/sys/mmu.h
deleted file mode 100644
index 269a2fb..0000000
--- a/include/sys/mmu.h
+++ /dev/null
@@ -1,226 +0,0 @@
-// This file contains definitions for the
-// x86 memory management unit (MMU).
-
-// Eflags register
-#define FL_CF           0x00000001      // Carry Flag
-#define FL_PF           0x00000004      // Parity Flag
-#define FL_AF           0x00000010      // Auxiliary carry Flag
-#define FL_ZF           0x00000040      // Zero Flag
-#define FL_SF           0x00000080      // Sign Flag
-#define FL_TF           0x00000100      // Trap Flag
-#define FL_IF           0x00000200      // Interrupt Enable
-#define FL_DF           0x00000400      // Direction Flag
-#define FL_OF           0x00000800      // Overflow Flag
-#define FL_IOPL_MASK    0x00003000      // I/O Privilege Level bitmask
-#define FL_IOPL_0       0x00000000      //   IOPL == 0
-#define FL_IOPL_1       0x00001000      //   IOPL == 1
-#define FL_IOPL_2       0x00002000      //   IOPL == 2
-#define FL_IOPL_3       0x00003000      //   IOPL == 3
-#define FL_NT           0x00004000      // Nested Task
-#define FL_RF           0x00010000      // Resume Flag
-#define FL_VM           0x00020000      // Virtual 8086 mode
-#define FL_AC           0x00040000      // Alignment Check
-#define FL_VIF          0x00080000      // Virtual Interrupt Flag
-#define FL_VIP          0x00100000      // Virtual Interrupt Pending
-#define FL_ID           0x00200000      // ID flag
-
-// Control Register flags
-#define CR0_PE          0x00000001      // Protection Enable
-#define CR0_MP          0x00000002      // Monitor coProcessor
-#define CR0_EM          0x00000004      // Emulation
-#define CR0_TS          0x00000008      // Task Switched
-#define CR0_ET          0x00000010      // Extension Type
-#define CR0_NE          0x00000020      // Numeric Errror
-#define CR0_WP          0x00010000      // Write Protect
-#define CR0_AM          0x00040000      // Alignment Mask
-#define CR0_NW          0x20000000      // Not Writethrough
-#define CR0_CD          0x40000000      // Cache Disable
-#define CR0_PG          0x80000000      // Paging
-
-#define CR4_PSE         0x00000010      // Page size extension
-
-#define SEG_KCODE 1  // kernel code
-#define SEG_KDATA 2  // kernel data+stack
-#define SEG_KCPU  3  // kernel per-cpu data
-#define SEG_UCODE 4  // user code
-#define SEG_UDATA 5  // user data+stack
-#define SEG_TSS   6  // this process's task state
-
-//PAGEBREAK!
-#ifndef __ASSEMBLER__
-// Segment Descriptor
-struct segdesc {
-	uint lim_15_0 : 16;  // Low bits of segment limit
-	uint base_15_0 : 16; // Low bits of segment base address
-	uint base_23_16 : 8; // Middle bits of segment base address
-	uint type : 4;       // Segment type (see STS_ constants)
-	uint s : 1;          // 0 = system, 1 = application
-	uint dpl : 2;        // Descriptor Privilege Level
-	uint p : 1;          // Present
-	uint lim_19_16 : 4;  // High bits of segment limit
-	uint avl : 1;        // Unused (available for software use)
-	uint rsv1 : 1;       // Reserved
-	uint db : 1;         // 0 = 16-bit segment, 1 = 32-bit segment
-	uint g : 1;          // Granularity: limit scaled by 4K when set
-	uint base_31_24 : 8; // High bits of segment base address
-};
-
-// Normal segment
-#define SEG(type, base, lim, dpl) (struct segdesc)    \
-{ ((lim) >> 12) & 0xffff, (uint)(base) & 0xffff,      \
-  ((uint)(base) >> 16) & 0xff, type, 1, dpl, 1,       \
-  (uint)(lim) >> 28, 0, 0, 1, 1, (uint)(base) >> 24 }
-#define SEG16(type, base, lim, dpl) (struct segdesc)  \
-{ (lim) & 0xffff, (uint)(base) & 0xffff,              \
-  ((uint)(base) >> 16) & 0xff, type, 1, dpl, 1,       \
-  (uint)(lim) >> 16, 0, 0, 1, 0, (uint)(base) >> 24 }
-#endif
-
-#define DPL_USER    0x3     // User DPL
-
-// Application segment type bits
-#define STA_X       0x8     // Executable segment
-#define STA_E       0x4     // Expand down (non-executable segments)
-#define STA_C       0x4     // Conforming code segment (executable only)
-#define STA_W       0x2     // Writeable (non-executable segments)
-#define STA_R       0x2     // Readable (executable segments)
-#define STA_A       0x1     // Accessed
-
-// System segment type bits
-#define STS_T16A    0x1     // Available 16-bit TSS
-#define STS_LDT     0x2     // Local Descriptor Table
-#define STS_T16B    0x3     // Busy 16-bit TSS
-#define STS_CG16    0x4     // 16-bit Call Gate
-#define STS_TG      0x5     // Task Gate / Coum Transmitions
-#define STS_IG16    0x6     // 16-bit Interrupt Gate
-#define STS_TG16    0x7     // 16-bit Trap Gate
-#define STS_T32A    0x9     // Available 32-bit TSS
-#define STS_T32B    0xB     // Busy 32-bit TSS
-#define STS_CG32    0xC     // 32-bit Call Gate
-#define STS_IG32    0xE     // 32-bit Interrupt Gate
-#define STS_TG32    0xF     // 32-bit Trap Gate
-
-// A virtual address 'la' has a three-part structure as follows:
-//
-// +--------10------+-------10-------+---------12----------+
-// | Page Directory |   Page Table   | Offset within Page  |
-// |      Index     |      Index     |                     |
-// +----------------+----------------+---------------------+
-//  \--- PDX(va) --/ \--- PTX(va) --/
-
-// page directory index
-#define PDX(va)         (((uint)(va) >> PDXSHIFT) & 0x3FF)
-
-// page table index
-#define PTX(va)         (((uint)(va) >> PTXSHIFT) & 0x3FF)
-
-// construct virtual address from indexes and offset
-#define PGADDR(d, t, o) ((uint)((d) << PDXSHIFT | (t) << PTXSHIFT | (o)))
-
-// Page directory and page table constants.
-#define NPDENTRIES      1024    // # directory entries per page directory
-#define NPTENTRIES      1024    // # PTEs per page table
-#define PGSIZE          4096    // bytes mapped by a page
-
-#define PGSHIFT         12      // log2(PGSIZE)
-#define PTXSHIFT        12      // offset of PTX in a linear address
-#define PDXSHIFT        22      // offset of PDX in a linear address
-
-#define PGROUNDUP(sz)  (((sz)+PGSIZE-1) & ~(PGSIZE-1))
-#define PGROUNDDOWN(a) (((a)) & ~(PGSIZE-1))
-
-// Page table/directory entry flags.
-#define PTE_P           0x001   // Present
-#define PTE_W           0x002   // Writeable
-#define PTE_U           0x004   // User
-#define PTE_PWT         0x008   // Write-Through
-#define PTE_PCD         0x010   // Cache-Disable
-#define PTE_A           0x020   // Accessed
-#define PTE_D           0x040   // Dirty
-#define PTE_PS          0x080   // Page Size
-#define PTE_MBZ         0x180   // Bits must be zero
-
-// Address in page table or page directory entry
-#define PTE_ADDR(pte)   ((uint)(pte) & ~0xFFF)
-#define PTE_FLAGS(pte)  ((uint)(pte) &  0xFFF)
-
-#ifndef __ASSEMBLER__
-typedef uint pte_t;
-
-// Task state segment format
-struct taskstate {
-	uint link;         // Old ts selector
-	uint esp0;         // Stack pointers and segment selectors
-	ushort ss0;        //   after an increase in privilege level
-	ushort padding1;
-	uint *esp1;
-	ushort ss1;
-	ushort padding2;
-	uint *esp2;
-	ushort ss2;
-	ushort padding3;
-	void *cr3;         // Page directory base
-	uint *eip;         // Saved state from last task switch
-	uint eflags;
-	uint eax;          // More saved state (registers)
-	uint ecx;
-	uint edx;
-	uint ebx;
-	uint *esp;
-	uint *ebp;
-	uint esi;
-	uint edi;
-	ushort es;         // Even more saved state (segment selectors)
-	ushort padding4;
-	ushort cs;
-	ushort padding5;
-	ushort ss;
-	ushort padding6;
-	ushort ds;
-	ushort padding7;
-	ushort fs;
-	ushort padding8;
-	ushort gs;
-	ushort padding9;
-	ushort ldt;
-	ushort padding10;
-	ushort t;          // Trap on task switch
-	ushort iomb;       // I/O map base address
-};
-
-// PAGEBREAK: 12
-// Gate descriptors for interrupts and traps
-struct gatedesc {
-	uint off_15_0 : 16;   // low 16 bits of offset in segment
-	uint cs : 16;         // code segment selector
-	uint args : 5;        // # args, 0 for interrupt/trap gates
-	uint rsv1 : 3;        // reserved(should be zero I guess)
-	uint type : 4;        // type(STS_{TG,IG32,TG32})
-	uint s : 1;           // must be 0 (system)
-	uint dpl : 2;         // descriptor(meaning new) privilege level
-	uint p : 1;           // Present
-	uint off_31_16 : 16;  // high bits of offset in segment
-};
-
-// Set up a normal interrupt/trap gate descriptor.
-// - istrap: 1 for a trap (= exception) gate, 0 for an interrupt gate.
-//   interrupt gate clears FL_IF, trap gate leaves FL_IF alone
-// - sel: Code segment selector for interrupt/trap handler
-// - off: Offset in code segment for interrupt/trap handler
-// - dpl: Descriptor Privilege Level -
-//        the privilege level required for software to invoke
-//        this interrupt/trap gate explicitly using an int instruction.
-#define SETGATE(gate, istrap, sel, off, d)                \
-{                                                         \
-  (gate).off_15_0 = (uint)(off) & 0xffff;                \
-  (gate).cs = (sel);                                      \
-  (gate).args = 0;                                        \
-  (gate).rsv1 = 0;                                        \
-  (gate).type = (istrap) ? STS_TG32 : STS_IG32;           \
-  (gate).s = 0;                                           \
-  (gate).dpl = (d);                                       \
-  (gate).p = 1;                                           \
-  (gate).off_31_16 = (uint)(off) >> 16;                  \
-}
-
-#endif
diff --git a/include/sys/mp.h b/include/sys/mp.h
deleted file mode 100644
index 47c90b3..0000000
--- a/include/sys/mp.h
+++ /dev/null
@@ -1,54 +0,0 @@
-// See MultiProcessor Specification Version 1.[14]
-
-struct mp {             // floating pointer
-	uchar signature[4];           // "_MP_"
-	void *physaddr;               // phys addr of MP config table
-	uchar length;                 // 1
-	uchar specrev;                // [14]
-	uchar checksum;               // all bytes must add up to 0
-	uchar type;                   // MP system config type
-	uchar imcrp;
-	uchar reserved[3];
-};
-
-struct mpconf {         // configuration table header
-	uchar signature[4];           // "PCMP"
-	ushort length;                // total table length
-	uchar version;                // [14]
-	uchar checksum;               // all bytes must add up to 0
-	uchar product[20];            // product id
-	uint *oemtable;               // OEM table pointer
-	ushort oemlength;             // OEM table length
-	ushort entry;                 // entry count
-	uint *lapicaddr;              // address of local APIC
-	ushort xlength;               // extended table length
-	uchar xchecksum;              // extended table checksum
-	uchar reserved;
-};
-
-struct mpproc {         // processor table entry
-	uchar type;                   // entry type (0)
-	uchar apicid;                 // local APIC id
-	uchar version;                // local APIC verison
-	uchar flags;                  // CPU flags
-#define MPBOOT 0x02           // This proc is the bootstrap processor.
-	uchar signature[4];           // CPU signature
-	uint feature;                 // feature flags from CPUID instruction
-	uchar reserved[8];
-};
-
-struct mpioapic {       // I/O APIC table entry
-	uchar type;                   // entry type (2)
-	uchar apicno;                 // I/O APIC id
-	uchar version;                // I/O APIC version
-	uchar flags;                  // I/O APIC flags
-	uint *addr;                  // I/O APIC address
-};
-
-// Table entry types
-#define MPPROC    0x00  // One per processor
-#define MPBUS     0x01  // One per bus
-#define MPIOAPIC  0x02  // One per I/O APIC
-#define MPIOINTR  0x03  // One per bus interrupt source
-#define MPLINTR   0x04  // One per system interrupt source
-
diff --git a/include/sys/param.h b/include/sys/param.h
index b6f6f46..8015ec2 100644
--- a/include/sys/param.h
+++ b/include/sys/param.h
@@ -1,12 +1,4 @@
-#define NPROC        64  // maximum number of processes
-#define KSTACKSIZE 4096  // size of per-process kernel stack
-#define NCPU          8  // maximum number of CPUs
-#define NOFILE       16  // open files per process
-#define NFILE       100  // open files per system
-#define NBUF         10  // size of disk block cache
-#define NINODE       50  // maximum number of active i-nodes
-#define NDEV         10  // maximum major device number
-#define ROOTDEV       1  // device number of file system root disk
-#define MAXARG       32  // max exec arguments
-#define LOGSIZE      10  // max data sectors in on-disk log
-
+#ifndef PARAM_H
+#define PARAM_H PARAM_H
+#include <kernel/param.h>
+#endif
diff --git a/include/sys/proc.h b/include/sys/proc.h
deleted file mode 100644
index 4ca33cb..0000000
--- a/include/sys/proc.h
+++ /dev/null
@@ -1,75 +0,0 @@
-// Segments in proc->gdt.
-#define NSEGS     7
-
-// Per-CPU state
-struct cpu {
-	uchar id;                    // Local APIC ID; index into cpus[] below
-	struct context *scheduler;   // swtch() here to enter scheduler
-	struct taskstate ts;         // Used by x86 to find stack for interrupt
-	struct segdesc gdt[NSEGS];   // x86 global descriptor table
-	volatile uint started;       // Has the CPU started?
-	int ncli;                    // Depth of pushcli nesting.
-	int intena;                  // Were interrupts enabled before pushcli?
-
-	// Cpu-local storage variables; see below
-	struct cpu *cpu;
-	struct proc *proc;           // The currently-running process.
-};
-
-extern struct cpu cpus[NCPU];
-extern int ncpu;
-
-// Per-CPU variables, holding pointers to the
-// current cpu and to the current process.
-// The asm suffix tells gcc to use "%gs:0" to refer to cpu
-// and "%gs:4" to refer to proc.  seginit sets up the
-// %gs segment register so that %gs refers to the memory
-// holding those two variables in the local cpu's struct cpu.
-// This is similar to how thread-local variables are implemented
-// in thread libraries such as Linux pthreads.
-extern struct cpu *cpu asm("%gs:0");       // &cpus[cpunum()]
-extern struct proc *proc asm("%gs:4");     // cpus[cpunum()].proc
-
-//PAGEBREAK: 17
-// Saved registers for kernel context switches.
-// Don't need to save all the segment registers (%cs, etc),
-// because they are constant across kernel contexts.
-// Don't need to save %eax, %ecx, %edx, because the
-// x86 convention is that the caller has saved them.
-// Contexts are stored at the bottom of the stack they
-// describe; the stack pointer is the address of the context.
-// The layout of the context matches the layout of the stack in swtch.S
-// at the "Switch stacks" comment. Switch doesn't save eip explicitly,
-// but it is on the stack and allocproc() manipulates it.
-struct context {
-	uint edi;
-	uint esi;
-	uint ebx;
-	uint ebp;
-	uint eip;
-};
-
-enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
-
-// Per-process state
-struct proc {
-	uint sz;                     // Size of process memory (bytes)
-	pde_t *pgdir;                // Page table
-	char *kstack;                // Bottom of kernel stack for this process
-	enum procstate state;        // Process state
-	volatile int pid;            // Process ID
-	struct proc *parent;         // Parent process
-	struct trapframe *tf;        // Trap frame for current syscall
-	struct context *context;     // swtch() here to run process
-	void *chan;                  // If non-zero, sleeping on chan
-	int killed;                  // If non-zero, have been killed
-	struct file *ofile[NOFILE];  // Open files
-	struct inode *cwd;           // Current directory
-	char name[16];               // Process name (debugging)
-};
-
-// Process memory is laid out contiguously, low addresses first:
-//   text
-//   original data and bss
-//   fixed-size stack
-//   expandable heap
diff --git a/include/sys/spinlock.h b/include/sys/spinlock.h
deleted file mode 100644
index ed320ac..0000000
--- a/include/sys/spinlock.h
+++ /dev/null
@@ -1,11 +0,0 @@
-// Mutual exclusion lock.
-struct spinlock {
-	uint locked;       // Is the lock held?
-
-	// For debugging:
-	char *name;        // Name of lock.
-	struct cpu *cpu;   // The cpu holding the lock.
-	uint pcs[10];      // The call stack (an array of program counters)
-	// that locked the lock.
-};
-
diff --git a/include/sys/stat.h b/include/sys/stat.h
index 7d82387..12ffb6e 100644
--- a/include/sys/stat.h
+++ b/include/sys/stat.h
@@ -1,11 +1,4 @@
-#define T_DIR  1   // Directory
-#define T_FILE 2   // File
-#define T_DEV  3   // Device
-
-struct stat {
-	short type;  // Type of file
-	int dev;     // File system's disk device
-	uint ino;    // Inode number
-	short nlink; // Number of links to file
-	uint size;   // Size of file in bytes
-};
+#ifndef STAT_H
+#define STAT_H STAT_H
+#include <kernel/stat.h>
+#endif
diff --git a/include/sys/syscall.h b/include/sys/syscall.h
index 223fa1d..6d22d96 100644
--- a/include/sys/syscall.h
+++ b/include/sys/syscall.h
@@ -1,22 +1,4 @@
-// System call numbers
-#define SYS_fork    1
-#define SYS_exit    2
-#define SYS_wait    3
-#define SYS_pipe    4
-#define SYS_read    5
-#define SYS_kill    6
-#define SYS_execve  7
-#define SYS_fstat   8
-#define SYS_chdir   9
-#define SYS_dup    10
-#define SYS_getpid 11
-#define SYS_sbrk   12
-#define SYS_sleep  13
-#define SYS_uptime 14
-#define SYS_open   15
-#define SYS_write  16
-#define SYS_mknod  17
-#define SYS_unlink 18
-#define SYS_link   19
-#define SYS_mkdir  20
-#define SYS_close  21
+#ifndef SYSCALL_H
+#define SYSCALL_H SYSCALL_H
+#include <kernel/syscall.h>
+#endif
diff --git a/include/sys/traps.h b/include/sys/traps.h
deleted file mode 100644
index 0bd1fd8..0000000
--- a/include/sys/traps.h
+++ /dev/null
@@ -1,38 +0,0 @@
-// x86 trap and interrupt constants.
-
-// Processor-defined:
-#define T_DIVIDE         0      // divide error
-#define T_DEBUG          1      // debug exception
-#define T_NMI            2      // non-maskable interrupt
-#define T_BRKPT          3      // breakpoint
-#define T_OFLOW          4      // overflow
-#define T_BOUND          5      // bounds check
-#define T_ILLOP          6      // illegal opcode
-#define T_DEVICE         7      // device not available
-#define T_DBLFLT         8      // double fault
-// #define T_COPROC      9      // reserved (not used since 486)
-#define T_TSS           10      // invalid task switch segment
-#define T_SEGNP         11      // segment not present
-#define T_STACK         12      // stack exception
-#define T_GPFLT         13      // general protection fault
-#define T_PGFLT         14      // page fault
-// #define T_RES        15      // reserved
-#define T_FPERR         16      // floating point error
-#define T_ALIGN         17      // aligment check
-#define T_MCHK          18      // machine check
-#define T_SIMDERR       19      // SIMD floating point error
-
-// These are arbitrarily chosen, but with care not to overlap
-// processor defined exceptions or interrupt vectors.
-#define T_SYSCALL       64      // system call
-#define T_DEFAULT      500      // catchall
-
-#define T_IRQ0          32      // IRQ 0 corresponds to int T_IRQ
-
-#define IRQ_TIMER        0
-#define IRQ_KBD          1
-#define IRQ_COM1         4
-#define IRQ_IDE         14
-#define IRQ_ERROR       19
-#define IRQ_SPURIOUS    31
-
diff --git a/include/sys/types.h b/include/sys/types.h
index e4adf64..1c25d0f 100644
--- a/include/sys/types.h
+++ b/include/sys/types.h
@@ -1,4 +1,4 @@
-typedef unsigned int   uint;
-typedef unsigned short ushort;
-typedef unsigned char  uchar;
-typedef uint pde_t;
+#ifndef TYPES_H
+#define TYPES_H TYPES_H
+#include <kernel/types.h>
+#endif
diff --git a/include/sys/x86.h b/include/sys/x86.h
deleted file mode 100644
index 76b76ad..0000000
--- a/include/sys/x86.h
+++ /dev/null
@@ -1,166 +0,0 @@
-// Routines to let C code use special x86 instructions.
-
-static inline uchar
-inb(ushort port) {
-	uchar data;
-
-	asm volatile("in %1,%0" : "=a"(data) : "d"(port));
-	return data;
-}
-
-static inline void
-insl(int port, void *addr, int cnt) {
-	asm volatile("cld; rep insl" :
-				 "=D"(addr), "=c"(cnt) :
-				 "d"(port), "0"(addr), "1"(cnt) :
-				 "memory", "cc");
-}
-
-static inline void
-outb(ushort port, uchar data) {
-	asm volatile("out %0,%1" : : "a"(data), "d"(port));
-}
-
-static inline void
-outw(ushort port, ushort data) {
-	asm volatile("out %0,%1" : : "a"(data), "d"(port));
-}
-
-static inline void
-outsl(int port, const void *addr, int cnt) {
-	asm volatile("cld; rep outsl" :
-				 "=S"(addr), "=c"(cnt) :
-				 "d"(port), "0"(addr), "1"(cnt) :
-				 "cc");
-}
-
-static inline void
-stosb(void *addr, int data, int cnt) {
-	asm volatile("cld; rep stosb" :
-				 "=D"(addr), "=c"(cnt) :
-				 "0"(addr), "1"(cnt), "a"(data) :
-				 "memory", "cc");
-}
-
-static inline void
-stosl(void *addr, int data, int cnt) {
-	asm volatile("cld; rep stosl" :
-				 "=D"(addr), "=c"(cnt) :
-				 "0"(addr), "1"(cnt), "a"(data) :
-				 "memory", "cc");
-}
-
-struct segdesc;
-
-static inline void
-lgdt(struct segdesc *p, int size) {
-	volatile ushort pd[3];
-
-	pd[0] = size - 1;
-	pd[1] = (uint)p;
-	pd[2] = (uint)p >> 16;
-
-	asm volatile("lgdt (%0)" : : "r"(pd));
-}
-
-struct gatedesc;
-
-static inline void
-lidt(struct gatedesc *p, int size) {
-	volatile ushort pd[3];
-
-	pd[0] = size - 1;
-	pd[1] = (uint)p;
-	pd[2] = (uint)p >> 16;
-
-	asm volatile("lidt (%0)" : : "r"(pd));
-}
-
-static inline void
-ltr(ushort sel) {
-	asm volatile("ltr %0" : : "r"(sel));
-}
-
-static inline uint
-readeflags(void) {
-	uint eflags;
-	asm volatile("pushfl; popl %0" : "=r"(eflags));
-	return eflags;
-}
-
-static inline void
-loadgs(ushort v) {
-	asm volatile("movw %0, %%gs" : : "r"(v));
-}
-
-static inline void
-cli(void) {
-	asm volatile("cli");
-}
-
-static inline void
-sti(void) {
-	asm volatile("sti");
-}
-
-static inline uint
-xchg(volatile uint *addr, uint newval) {
-	uint result;
-
-	// The + in "+m" denotes a read-modify-write operand.
-	asm volatile("lock; xchgl %0, %1" :
-				 "+m"(*addr), "=a"(result) :
-				 "1"(newval) :
-				 "cc");
-	return result;
-}
-
-static inline uint
-rcr2(void) {
-	uint val;
-	asm volatile("movl %%cr2,%0" : "=r"(val));
-	return val;
-}
-
-static inline void
-lcr3(uint val) {
-	asm volatile("movl %0,%%cr3" : : "r"(val));
-}
-
-//PAGEBREAK: 36
-// Layout of the trap frame built on the stack by the
-// hardware and by trapasm.S, and passed to trap().
-struct trapframe {
-	// registers as pushed by pusha
-	uint edi;
-	uint esi;
-	uint ebp;
-	uint oesp;      // useless & ignored
-	uint ebx;
-	uint edx;
-	uint ecx;
-	uint eax;
-
-	// rest of trap frame
-	ushort gs;
-	ushort padding1;
-	ushort fs;
-	ushort padding2;
-	ushort es;
-	ushort padding3;
-	ushort ds;
-	ushort padding4;
-	uint trapno;
-
-	// below here defined by x86 hardware
-	uint err;
-	uint eip;
-	ushort cs;
-	ushort padding5;
-	uint eflags;
-
-	// below here only when crossing rings, such as from user to kernel
-	uint esp;
-	ushort ss;
-	ushort padding6;
-};
diff --git a/include/user.h b/include/user.h
index 7d4ab8d..a566f44 100644
--- a/include/user.h
+++ b/include/user.h
@@ -17,7 +17,7 @@ int close(int);
 int kill(int);
 
 int execve(const char *, char **, char **);
-#define exec(pa, arg) execve(pa,arg,environ)
+int exec(const char *, char **);
 
 int open(const char *, int);
 int mknod(const char *, short, short);
@@ -32,6 +32,12 @@ char *sbrk(int);
 int sleep(int);
 int uptime(void);
 
+#define SEEK_SET 0
+#define SEEK_CUR 1
+#define SEEK_END 2
+int tell(int);
+int seek(int, int, int);
+
 // ulib.c
 int stat(char *, struct stat *);
 void printf(int, const char *, ...);
diff --git a/kernel/Makefile b/kernel/Makefile
index 5dee060..46add47 100644
--- a/kernel/Makefile
+++ b/kernel/Makefile
@@ -1,5 +1,5 @@
-CFLAGS += -I ../include/sys
-ASFLAGS += -I ../include/sys
+CFLAGS += -I ../include/kernel
+ASFLAGS += -I ../include/kernel
 
 all: bootblock kernel
 OBJS = \
diff --git a/kernel/syscall/syscall.c b/kernel/syscall/syscall.c
index e7619d9..de82202 100644
--- a/kernel/syscall/syscall.c
+++ b/kernel/syscall/syscall.c
@@ -108,6 +108,9 @@ extern int sys_wait(void);
 extern int sys_write(void);
 extern int sys_uptime(void);
 
+extern int sys_tell(void);
+extern int sys_seek(void);
+
 static int (*syscalls[])(void) = {
 	[SYS_fork]    sys_fork,
 	[SYS_exit]    sys_exit,
@@ -130,6 +133,9 @@ static int (*syscalls[])(void) = {
 	[SYS_link]    sys_link,
 	[SYS_mkdir]   sys_mkdir,
 	[SYS_close]   sys_close,
+
+	[SYS_tell]   sys_tell,
+	[SYS_seek]   sys_seek,
 };
 
 void
diff --git a/kernel/syscall/sysfile.c b/kernel/syscall/sysfile.c
index 7ef4b22..4a6bb3a 100644
--- a/kernel/syscall/sysfile.c
+++ b/kernel/syscall/sysfile.c
@@ -99,6 +99,52 @@ sys_write(void) {
 	return filewrite(f, p, n);
 }
 
+// Получить позицию чтения
+int
+sys_tell(void) {
+	struct file *f;
+	uint *p;
+
+	if (argfd(0, 0, &f) < 0) {
+		return -1;
+	}
+
+	return f->off;
+}
+
+// Установить позицию чтения
+int
+sys_seek(void) {
+	struct file *f;
+	struct stat *st;
+	uint pos, origin;
+
+	if (argfd(0, 0, &f) < 0 || argint(1, &pos) < 0 || argint(2, &origin) < 0) {
+		return -1;
+	}
+
+	if (f->type != FD_INODE) {
+		return -1;
+	}
+
+	switch(origin) {
+		case 1:
+			f->off += pos;
+			break;
+		case 2:
+			ilock(f->ip);
+			f->off = f->ip->size - pos -1;
+			iunlock(f->ip);
+			break;
+		case 0:
+		default:
+			f->off = pos;
+			break;
+	}
+
+	return 0;
+}
+
 int
 sys_close(void) {
 	int fd;
diff --git a/libc/malloc.c b/libc/malloc.c
index e6b0a8f..d8bfeda 100644
--- a/libc/malloc.c
+++ b/libc/malloc.c
@@ -114,14 +114,12 @@ void free(void *ap) {
 }
 
 void *realloc(void *ptr, size_t size) {
-	Header *bp;
-
-	bp = (Header *)ptr - 1;
+	Header *bp = (Header *)ptr - 1;
+	size_t h_size = bp->s.size * sizeof(Header);
 
 	void *ret_ptr = malloc(size);
-	// FIXME: доделать (не уверен в правильности s.size)
-	// по идее нужно всё циклом обходить
-	ret_ptr = memmove(ret_ptr, ptr, (size < bp->s.size) ? size : bp->s.size);
+
+	ret_ptr = memmove(ret_ptr, ptr, (size < h_size) ? size : h_size);
 
 	free(ptr);
 
diff --git a/mkfs/Makefile b/mkfs/Makefile
index 7ed115c..0054b8c 100644
--- a/mkfs/Makefile
+++ b/mkfs/Makefile
@@ -2,8 +2,8 @@
 
 all: mkfs
 
-mkfs: mkfs.c fsutil.c ../include/sys/fs.h
-	gcc -I .. -I -Wall -o mkfs mkfs.c
+mkfs: mkfs.c fsutil.c ../include/kernel/fs.h
+	gcc -I ../include  -Wall -o mkfs mkfs.c
 
 clean:
 	rm -f mkfs *.o
diff --git a/mkfs/mkfs.c b/mkfs/mkfs.c
index 6b772bc..5bcca6d 100644
--- a/mkfs/mkfs.c
+++ b/mkfs/mkfs.c
@@ -11,10 +11,10 @@
 
 #define stat xv6_stat  // avoid clash with host struct stat
 #define dirent xv6_dirent  // avoid clash with host struct stat
-#include "include/sys/types.h"
-#include "include/sys/fs.h"
-#include "include/sys/stat.h"
-#include "include/sys/param.h"
+#include "kernel/types.h"
+#include "kernel/fs.h"
+#include "kernel/stat.h"
+#include "kernel/param.h"
 #undef stat
 #undef dirent
 
